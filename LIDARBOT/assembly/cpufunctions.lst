   1               		.file	"cpufunctions.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/manu/github/arduino/LIDARBOT/",100,0,2,.Ltext0
   8               		.stabs	"source/os_rios/cpufunctions.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=r(0,2);0;127;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"__int128:t(0,6)=@s128;r(0,6);02000000000000000000000000000000000000000000;0177777777777777
  18               		.stabs	"__int128 unsigned:t(0,7)=@s128;r(0,7);0;03777777777777777777777777777777777777777777;",128
  19               		.stabs	"long long int:t(0,8)=@s64;r(0,8);01000000000000000000000;00777777777777777777777;",128,0,0
  20               		.stabs	"long long unsigned int:t(0,9)=@s64;r(0,9);0;01777777777777777777777;",128,0,0,0
  21               		.stabs	"short int:t(0,10)=r(0,10);-32768;32767;",128,0,0,0
  22               		.stabs	"short unsigned int:t(0,11)=r(0,11);0;0177777;",128,0,0,0
  23               		.stabs	"signed char:t(0,12)=@s8;r(0,12);-128;127;",128,0,0,0
  24               		.stabs	"unsigned char:t(0,13)=@s8;r(0,13);0;255;",128,0,0,0
  25               		.stabs	"float:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"double:t(0,15)=r(0,1);4;0;",128,0,0,0
  27               		.stabs	"long double:t(0,16)=r(0,1);4;0;",128,0,0,0
  28               		.stabs	"short _Fract:t(0,17)=r(0,1);1;0;",128,0,0,0
  29               		.stabs	"_Fract:t(0,18)=r(0,1);2;0;",128,0,0,0
  30               		.stabs	"long _Fract:t(0,19)=r(0,1);4;0;",128,0,0,0
  31               		.stabs	"long long _Fract:t(0,20)=r(0,1);8;0;",128,0,0,0
  32               		.stabs	"unsigned short _Fract:t(0,21)=r(0,1);1;0;",128,0,0,0
  33               		.stabs	"unsigned _Fract:t(0,22)=r(0,1);2;0;",128,0,0,0
  34               		.stabs	"unsigned long _Fract:t(0,23)=r(0,1);4;0;",128,0,0,0
  35               		.stabs	"unsigned long long _Fract:t(0,24)=r(0,1);8;0;",128,0,0,0
  36               		.stabs	"_Sat short _Fract:t(0,25)=r(0,1);1;0;",128,0,0,0
  37               		.stabs	"_Sat _Fract:t(0,26)=r(0,1);2;0;",128,0,0,0
  38               		.stabs	"_Sat long _Fract:t(0,27)=r(0,1);4;0;",128,0,0,0
  39               		.stabs	"_Sat long long _Fract:t(0,28)=r(0,1);8;0;",128,0,0,0
  40               		.stabs	"_Sat unsigned short _Fract:t(0,29)=r(0,1);1;0;",128,0,0,0
  41               		.stabs	"_Sat unsigned _Fract:t(0,30)=r(0,1);2;0;",128,0,0,0
  42               		.stabs	"_Sat unsigned long _Fract:t(0,31)=r(0,1);4;0;",128,0,0,0
  43               		.stabs	"_Sat unsigned long long _Fract:t(0,32)=r(0,1);8;0;",128,0,0,0
  44               		.stabs	"short _Accum:t(0,33)=r(0,1);2;0;",128,0,0,0
  45               		.stabs	"_Accum:t(0,34)=r(0,1);4;0;",128,0,0,0
  46               		.stabs	"long _Accum:t(0,35)=r(0,1);8;0;",128,0,0,0
  47               		.stabs	"long long _Accum:t(0,36)=r(0,1);8;0;",128,0,0,0
  48               		.stabs	"unsigned short _Accum:t(0,37)=r(0,1);2;0;",128,0,0,0
  49               		.stabs	"unsigned _Accum:t(0,38)=r(0,1);4;0;",128,0,0,0
  50               		.stabs	"unsigned long _Accum:t(0,39)=r(0,1);8;0;",128,0,0,0
  51               		.stabs	"unsigned long long _Accum:t(0,40)=r(0,1);8;0;",128,0,0,0
  52               		.stabs	"_Sat short _Accum:t(0,41)=r(0,1);2;0;",128,0,0,0
  53               		.stabs	"_Sat _Accum:t(0,42)=r(0,1);4;0;",128,0,0,0
  54               		.stabs	"_Sat long _Accum:t(0,43)=r(0,1);8;0;",128,0,0,0
  55               		.stabs	"_Sat long long _Accum:t(0,44)=r(0,1);8;0;",128,0,0,0
  56               		.stabs	"_Sat unsigned short _Accum:t(0,45)=r(0,1);2;0;",128,0,0,0
  57               		.stabs	"_Sat unsigned _Accum:t(0,46)=r(0,1);4;0;",128,0,0,0
  58               		.stabs	"_Sat unsigned long _Accum:t(0,47)=r(0,1);8;0;",128,0,0,0
  59               		.stabs	"_Sat unsigned long long _Accum:t(0,48)=r(0,1);8;0;",128,0,0,0
  60               		.stabs	"void:t(0,49)=(0,49)",128,0,0,0
  61               		.stabs	"source/os_rios/cpufunctions.h",130,0,0,0
  62               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/avr/io.h",130,0,0,0
  63               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/avr/sfr_defs.h",130,0,0,0
  64               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/inttypes.h",130,0,0,0
  65               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/stdint.h",130,0,0,0
  66               		.stabs	"int8_t:t(5,1)=(0,12)",128,0,125,0
  67               		.stabs	"uint8_t:t(5,2)=(0,13)",128,0,126,0
  68               		.stabs	"int16_t:t(5,3)=(0,1)",128,0,127,0
  69               		.stabs	"uint16_t:t(5,4)=(0,4)",128,0,128,0
  70               		.stabs	"int32_t:t(5,5)=(0,3)",128,0,129,0
  71               		.stabs	"uint32_t:t(5,6)=(0,5)",128,0,130,0
  72               		.stabs	"int64_t:t(5,7)=(0,8)",128,0,132,0
  73               		.stabs	"uint64_t:t(5,8)=(0,9)",128,0,133,0
  74               		.stabs	"intptr_t:t(5,9)=(5,3)",128,0,146,0
  75               		.stabs	"uintptr_t:t(5,10)=(5,4)",128,0,151,0
  76               		.stabs	"int_least8_t:t(5,11)=(5,1)",128,0,163,0
  77               		.stabs	"uint_least8_t:t(5,12)=(5,2)",128,0,168,0
  78               		.stabs	"int_least16_t:t(5,13)=(5,3)",128,0,173,0
  79               		.stabs	"uint_least16_t:t(5,14)=(5,4)",128,0,178,0
  80               		.stabs	"int_least32_t:t(5,15)=(5,5)",128,0,183,0
  81               		.stabs	"uint_least32_t:t(5,16)=(5,6)",128,0,188,0
  82               		.stabs	"int_least64_t:t(5,17)=(5,7)",128,0,196,0
  83               		.stabs	"uint_least64_t:t(5,18)=(5,8)",128,0,203,0
  84               		.stabs	"int_fast8_t:t(5,19)=(5,1)",128,0,217,0
  85               		.stabs	"uint_fast8_t:t(5,20)=(5,2)",128,0,222,0
  86               		.stabs	"int_fast16_t:t(5,21)=(5,3)",128,0,227,0
  87               		.stabs	"uint_fast16_t:t(5,22)=(5,4)",128,0,232,0
  88               		.stabs	"int_fast32_t:t(5,23)=(5,5)",128,0,237,0
  89               		.stabs	"uint_fast32_t:t(5,24)=(5,6)",128,0,242,0
  90               		.stabs	"int_fast64_t:t(5,25)=(5,7)",128,0,250,0
  91               		.stabs	"uint_fast64_t:t(5,26)=(5,8)",128,0,257,0
  92               		.stabs	"intmax_t:t(5,27)=(5,7)",128,0,277,0
  93               		.stabs	"uintmax_t:t(5,28)=(5,8)",128,0,282,0
  94               		.stabn	162,0,0,0
  95               		.stabs	"int_farptr_t:t(4,1)=(5,5)",128,0,77,0
  96               		.stabs	"uint_farptr_t:t(4,2)=(5,6)",128,0,81,0
  97               		.stabn	162,0,0,0
  98               		.stabn	162,0,0,0
  99               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/avr/fuse.h",130,0,0,0
 100               		.stabs	"__fuse_t:t(6,1)=(6,2)=s3low:(0,13),0,8;high:(0,13),8,8;extended:(0,13),16,8;;",128,0,244,0
 101               		.stabn	162,0,0,0
 102               		.stabn	162,0,0,0
 103               		.stabn	162,0,0,0
 104               		.stabs	"clocksetup:F(0,49)",36,0,3,clocksetup
 105               	.global	clocksetup
 106               		.type	clocksetup, @function
 107               	clocksetup:
 108               		.stabd	46,0,0
   1:source/os_rios/cpufunctions.c **** #include "cpufunctions.h"
   2:source/os_rios/cpufunctions.c **** 
   3:source/os_rios/cpufunctions.c **** void clocksetup(void){
 109               		.stabn	68,0,3,.LM0-.LFBB1
 110               	.LM0:
 111               	.LFBB1:
 112               	/* prologue: function */
 113               	/* frame size = 0 */
 114               	/* stack size = 0 */
 115               	.L__stack_usage = 0
   4:source/os_rios/cpufunctions.c ****   /* CPU Clock setup
   5:source/os_rios/cpufunctions.c ****    * ---------------
   6:source/os_rios/cpufunctions.c ****    *
   7:source/os_rios/cpufunctions.c ****    * The clock source for the board is the on-board 16Mhz crystal that is
   8:source/os_rios/cpufunctions.c ****    * shipped with the Arduino Uno board. The system clock will be used for
   9:source/os_rios/cpufunctions.c ****    * PWM motor control and UART. So a clock pre-scalar has to be chosen such
  10:source/os_rios/cpufunctions.c ****    * that motor control and UART communication can occur smoothly. A 8 MHzclock
  11:source/os_rios/cpufunctions.c ****    * clock should yeild a minimal error UART communication and a motor PWM
  12:source/os_rios/cpufunctions.c ****    * that would work at 500 Hz. Therefore to get 4 Mhz, the clock needs to be
  13:source/os_rios/cpufunctions.c ****    * divided by a pre-scalar of 4. Hence we can set CLKPS1 a.k.a CKDIV4.
  14:source/os_rios/cpufunctions.c ****    */
  15:source/os_rios/cpufunctions.c **** 
  16:source/os_rios/cpufunctions.c ****   // CLKPCE lock needs to be written first to actually change the pre-scalar
  17:source/os_rios/cpufunctions.c ****   CLKPR = (1<<CLKPCE);
 116               		.stabn	68,0,17,.LM1-.LFBB1
 117               	.LM1:
 118 0000 E1E6      		ldi r30,lo8(97)
 119 0002 F0E0      		ldi r31,0
 120 0004 80E8      		ldi r24,lo8(-128)
 121 0006 8083      		st Z,r24
  18:source/os_rios/cpufunctions.c ****   CLKPR = (1<<CLKPS1);
 122               		.stabn	68,0,18,.LM2-.LFBB1
 123               	.LM2:
 124 0008 82E0      		ldi r24,lo8(2)
 125 000a 8083      		st Z,r24
 126 000c 0895      		ret
 127               		.size	clocksetup, .-clocksetup
 128               	.Lscope1:
 129               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 130               		.stabd	78,0,0
 131               		.stabs	"pwmtimer2setup:F(0,49)",36,0,21,pwmtimer2setup
 132               	.global	pwmtimer2setup
 133               		.type	pwmtimer2setup, @function
 134               	pwmtimer2setup:
 135               		.stabd	46,0,0
  19:source/os_rios/cpufunctions.c **** }
  20:source/os_rios/cpufunctions.c **** 
  21:source/os_rios/cpufunctions.c **** void pwmtimer2setup(void){
 136               		.stabn	68,0,21,.LM3-.LFBB2
 137               	.LM3:
 138               	.LFBB2:
 139               	/* prologue: function */
 140               	/* frame size = 0 */
 141               	/* stack size = 0 */
 142               	.L__stack_usage = 0
  22:source/os_rios/cpufunctions.c ****   /* TIMER2 setup for PWM Motor Control
  23:source/os_rios/cpufunctions.c ****    * ----------------------------------
  24:source/os_rios/cpufunctions.c ****    *
  25:source/os_rios/cpufunctions.c ****    * From the datasheet:
  26:source/os_rios/cpufunctions.c ****    *
  27:source/os_rios/cpufunctions.c ****    * PWM_FREQUENCY = CPU_CLOCK_FREQUENCY/(N*256)
  28:source/os_rios/cpufunctions.c ****    *
  29:source/os_rios/cpufunctions.c ****    * where N is the clock pre-scalar to give us our required PWM frequency
  30:source/os_rios/cpufunctions.c ****    * The datasheet gives us select choices for this prescalar out of which the
  31:source/os_rios/cpufunctions.c ****    * value of N=32 would the most favourable for us (also standard). If we set
  32:source/os_rios/cpufunctions.c ****    * it to 32 we get:
  33:source/os_rios/cpufunctions.c ****    *
  34:source/os_rios/cpufunctions.c ****    * PWM_FREQUENCY = (4000000)/(32*256) ~ 488 HZ. (~ 2.04 ms)
  35:source/os_rios/cpufunctions.c ****    *
  36:source/os_rios/cpufunctions.c ****    * This frequncy should help the motor operate smoothly throughout the Duty
  37:source/os_rios/cpufunctions.c ****    * Cycle range controlled by OCR2A and OCR2B for the two motor banks.
  38:source/os_rios/cpufunctions.c ****    *
  39:source/os_rios/cpufunctions.c ****    */
  40:source/os_rios/cpufunctions.c **** 
  41:source/os_rios/cpufunctions.c ****   /* Set compare output mode to clear OCR2A and OCR2B on compare match */
  42:source/os_rios/cpufunctions.c ****   TCCR2A |=  (1<<COM2A1) | (1<<COM2B1);
 143               		.stabn	68,0,42,.LM4-.LFBB2
 144               	.LM4:
 145 000e E0EB      		ldi r30,lo8(-80)
 146 0010 F0E0      		ldi r31,0
 147 0012 8081      		ld r24,Z
 148 0014 806A      		ori r24,lo8(-96)
 149 0016 8083      		st Z,r24
  43:source/os_rios/cpufunctions.c **** 
  44:source/os_rios/cpufunctions.c ****   /* Waveform Generation Mode: WGM02 = 1, WGM01 = 1, WGM00 = 1 */
  45:source/os_rios/cpufunctions.c ****   TCCR2A |= (1<<WGM22) | (1<<WGM21) | (1<<WGM20);
 150               		.stabn	68,0,45,.LM5-.LFBB2
 151               	.LM5:
 152 0018 8081      		ld r24,Z
 153 001a 8B60      		ori r24,lo8(11)
 154 001c 8083      		st Z,r24
  46:source/os_rios/cpufunctions.c **** 
  47:source/os_rios/cpufunctions.c ****   /* We will initialize PWM Duty Cycle to zero */
  48:source/os_rios/cpufunctions.c ****   OCR2A = 0;
 155               		.stabn	68,0,48,.LM6-.LFBB2
 156               	.LM6:
 157 001e 1092 B300 		sts 179,__zero_reg__
  49:source/os_rios/cpufunctions.c ****   OCR2B = 0;
 158               		.stabn	68,0,49,.LM7-.LFBB2
 159               	.LM7:
 160 0022 1092 B400 		sts 180,__zero_reg__
  50:source/os_rios/cpufunctions.c **** 
  51:source/os_rios/cpufunctions.c ****   // Timer pre-scalar for ~488 Hz is 32. We want this to be the last step since
  52:source/os_rios/cpufunctions.c ****   // this will actually start the timer counter.
  53:source/os_rios/cpufunctions.c ****   TCCR2B |=  (1<<CS21) | (1<<CS20);
 161               		.stabn	68,0,53,.LM8-.LFBB2
 162               	.LM8:
 163 0026 E1EB      		ldi r30,lo8(-79)
 164 0028 F0E0      		ldi r31,0
 165 002a 8081      		ld r24,Z
 166 002c 8360      		ori r24,lo8(3)
 167 002e 8083      		st Z,r24
 168 0030 0895      		ret
 169               		.size	pwmtimer2setup, .-pwmtimer2setup
 170               	.Lscope2:
 171               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 172               		.stabd	78,0,0
 173               		.stabs	"LIDARreadtimer0setup:F(0,49)",36,0,56,LIDARreadtimer0setup
 174               	.global	LIDARreadtimer0setup
 175               		.type	LIDARreadtimer0setup, @function
 176               	LIDARreadtimer0setup:
 177               		.stabd	46,0,0
  54:source/os_rios/cpufunctions.c **** }
  55:source/os_rios/cpufunctions.c **** 
  56:source/os_rios/cpufunctions.c **** void LIDARreadtimer0setup(void){
 178               		.stabn	68,0,56,.LM9-.LFBB3
 179               	.LM9:
 180               	.LFBB3:
 181               	/* prologue: function */
 182               	/* frame size = 0 */
 183               	/* stack size = 0 */
 184               	.L__stack_usage = 0
  57:source/os_rios/cpufunctions.c ****   /* TIMER0 setup for USART receive buffer read
  58:source/os_rios/cpufunctions.c ****    * ------------------------------------------
  59:source/os_rios/cpufunctions.c ****    * If we set up the timer in Clear Timer on Compare or simply CTC mode, the
  60:source/os_rios/cpufunctions.c ****    * frequency at which the timer will be cleared is the out task rate. So we
  61:source/os_rios/cpufunctions.c ****    * know that we read a byte form the UART recieve register every 1040 us
  62:source/os_rios/cpufunctions.c ****    * roughly. It is not exactly 1040 us always therefore we have an interrupt
  63:source/os_rios/cpufunctions.c ****    * take care of receiving for us. But we can definitely set up an exact "task
  64:source/os_rios/cpufunctions.c ****    * rate" for us to read out the data from the buffer that the USART ISR fills.
  65:source/os_rios/cpufunctions.c ****    * Sampling at half the time would seem enough at first but we have to
  66:source/os_rios/cpufunctions.c ****    * account for the overhead of managing the buffer and processing each byte.
  67:source/os_rios/cpufunctions.c ****    * After some tuning an OCR value of 20 and a pre-scalar of 64 seemed to do the
  68:source/os_rios/cpufunctions.c ****    * trick. But why? Well the resulting time when the interrupt triggers will be
  69:source/os_rios/cpufunctions.c ****    * 320 us. I.e. our pre-scalar is 64 so the resuting tick of the timer will be
  70:source/os_rios/cpufunctions.c ****    * 1/(4000000/64) = 16 us. If we count to twenty with these ticks we will be at
  71:source/os_rios/cpufunctions.c ****    * 320 us, which is 3.25 times the rate at which the USART fills up the buffer.
  72:source/os_rios/cpufunctions.c ****    * This means we have a task rate of 320 us for processing a buffer byte.
  73:source/os_rios/cpufunctions.c ****    */
  74:source/os_rios/cpufunctions.c **** 
  75:source/os_rios/cpufunctions.c ****   /* Set compare output mode to clear OCR2A on compare match */
  76:source/os_rios/cpufunctions.c ****   TCCR0A |=  (1<<COM0A1);
 185               		.stabn	68,0,76,.LM10-.LFBB3
 186               	.LM10:
 187 0032 84B5      		in r24,0x24
 188 0034 8068      		ori r24,lo8(-128)
 189 0036 84BD      		out 0x24,r24
  77:source/os_rios/cpufunctions.c **** 
  78:source/os_rios/cpufunctions.c ****   /* Waveform Generation Mode: WGM02 = 0, WGM01 = 1, WGM00 = 0 -> CTC */
  79:source/os_rios/cpufunctions.c ****   TCCR0A |= (1<<WGM01);
 190               		.stabn	68,0,79,.LM11-.LFBB3
 191               	.LM11:
 192 0038 84B5      		in r24,0x24
 193 003a 8260      		ori r24,lo8(2)
 194 003c 84BD      		out 0x24,r24
  80:source/os_rios/cpufunctions.c **** 
  81:source/os_rios/cpufunctions.c ****   /* We will initialize OCR0A to  the value we have chosen */
  82:source/os_rios/cpufunctions.c ****   OCR0A = 20;
 195               		.stabn	68,0,82,.LM12-.LFBB3
 196               	.LM12:
 197 003e 84E1      		ldi r24,lo8(20)
 198 0040 87BD      		out 0x27,r24
  83:source/os_rios/cpufunctions.c **** 
  84:source/os_rios/cpufunctions.c ****   /* Let us choose the timer pre-scalar of 64 (will start the timer) */
  85:source/os_rios/cpufunctions.c ****   TCCR0B |= (1<<CS01) | (1<<CS00);
 199               		.stabn	68,0,85,.LM13-.LFBB3
 200               	.LM13:
 201 0042 85B5      		in r24,0x25
 202 0044 8360      		ori r24,lo8(3)
 203 0046 85BD      		out 0x25,r24
  86:source/os_rios/cpufunctions.c **** 
  87:source/os_rios/cpufunctions.c ****   /* Finally lets enable the Timer 0 compare interrupt */
  88:source/os_rios/cpufunctions.c ****   TIMSK0 |= (1<<OCIE0A);
 204               		.stabn	68,0,88,.LM14-.LFBB3
 205               	.LM14:
 206 0048 EEE6      		ldi r30,lo8(110)
 207 004a F0E0      		ldi r31,0
 208 004c 8081      		ld r24,Z
 209 004e 8260      		ori r24,lo8(2)
 210 0050 8083      		st Z,r24
 211 0052 0895      		ret
 212               		.size	LIDARreadtimer0setup, .-LIDARreadtimer0setup
 213               	.Lscope3:
 214               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 215               		.stabd	78,0,0
 216               		.stabs	"propulsiontimer1setup:F(0,49)",36,0,91,propulsiontimer1setup
 217               	.global	propulsiontimer1setup
 218               		.type	propulsiontimer1setup, @function
 219               	propulsiontimer1setup:
 220               		.stabd	46,0,0
  89:source/os_rios/cpufunctions.c **** }
  90:source/os_rios/cpufunctions.c **** 
  91:source/os_rios/cpufunctions.c **** void propulsiontimer1setup(void) {
 221               		.stabn	68,0,91,.LM15-.LFBB4
 222               	.LM15:
 223               	.LFBB4:
 224               	/* prologue: function */
 225               	/* frame size = 0 */
 226               	/* stack size = 0 */
 227               	.L__stack_usage = 0
  92:source/os_rios/cpufunctions.c ****   /* Set compare output mode to clear OCR1A on compare match */
  93:source/os_rios/cpufunctions.c ****   TCCR1A |= (1<<COM1A1);
 228               		.stabn	68,0,93,.LM16-.LFBB4
 229               	.LM16:
 230 0054 E0E8      		ldi r30,lo8(-128)
 231 0056 F0E0      		ldi r31,0
 232 0058 8081      		ld r24,Z
 233 005a 8068      		ori r24,lo8(-128)
 234 005c 8083      		st Z,r24
  94:source/os_rios/cpufunctions.c **** 
  95:source/os_rios/cpufunctions.c ****   /* Waveform Generation Mode: WGM12 = 0, WGM11 = 0, WGM10 = 0 -> CTC */
  96:source/os_rios/cpufunctions.c ****   TCCR1B |= (1<<WGM12);
 235               		.stabn	68,0,96,.LM17-.LFBB4
 236               	.LM17:
 237 005e E1E8      		ldi r30,lo8(-127)
 238 0060 F0E0      		ldi r31,0
 239 0062 8081      		ld r24,Z
 240 0064 8860      		ori r24,lo8(8)
 241 0066 8083      		st Z,r24
  97:source/os_rios/cpufunctions.c **** 
  98:source/os_rios/cpufunctions.c ****   /* OCRA1 low and high needs to be set to give us ~ 4 ms*/
  99:source/os_rios/cpufunctions.c ****   OCR1A |= 1953;
 242               		.stabn	68,0,99,.LM18-.LFBB4
 243               	.LM18:
 244 0068 A8E8      		ldi r26,lo8(-120)
 245 006a B0E0      		ldi r27,0
 246 006c 8D91      		ld r24,X+
 247 006e 9C91      		ld r25,X
 248 0070 1197      		sbiw r26,1
 249 0072 816A      		ori r24,161
 250 0074 9760      		ori r25,7
 251 0076 1196      		adiw r26,1
 252 0078 9C93      		st X,r25
 253 007a 8E93      		st -X,r24
 100:source/os_rios/cpufunctions.c **** 
 101:source/os_rios/cpufunctions.c ****   /* Set up the pre-scalar for timer 1*/
 102:source/os_rios/cpufunctions.c ****   TCCR1B |= (1<<CS12) | (1<<CS10);
 254               		.stabn	68,0,102,.LM19-.LFBB4
 255               	.LM19:
 256 007c 8081      		ld r24,Z
 257 007e 8560      		ori r24,lo8(5)
 258 0080 8083      		st Z,r24
 103:source/os_rios/cpufunctions.c **** 
 104:source/os_rios/cpufunctions.c ****   /* Finally lets enable the Timer 1 compare interrupt */
 105:source/os_rios/cpufunctions.c ****   TIMSK1 |= (1<<OCIE1A);
 259               		.stabn	68,0,105,.LM20-.LFBB4
 260               	.LM20:
 261 0082 EFE6      		ldi r30,lo8(111)
 262 0084 F0E0      		ldi r31,0
 263 0086 8081      		ld r24,Z
 264 0088 8260      		ori r24,lo8(2)
 265 008a 8083      		st Z,r24
 266 008c 0895      		ret
 267               		.size	propulsiontimer1setup, .-propulsiontimer1setup
 268               	.Lscope4:
 269               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 270               		.stabd	78,0,0
 271               		.stabs	"hardwareserialsetup:F(0,49)",36,0,108,hardwareserialsetup
 272               	.global	hardwareserialsetup
 273               		.type	hardwareserialsetup, @function
 274               	hardwareserialsetup:
 275               		.stabd	46,0,0
 106:source/os_rios/cpufunctions.c **** }
 107:source/os_rios/cpufunctions.c **** 
 108:source/os_rios/cpufunctions.c **** void hardwareserialsetup(void){
 276               		.stabn	68,0,108,.LM21-.LFBB5
 277               	.LM21:
 278               	.LFBB5:
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 0 */
 282               	.L__stack_usage = 0
 109:source/os_rios/cpufunctions.c ****   /* Hardware UART Control Registers setup
 110:source/os_rios/cpufunctions.c ****    * -------------------------------------
 111:source/os_rios/cpufunctions.c ****    *
 112:source/os_rios/cpufunctions.c ****    * Registers needed to be configured from the datasheet:
 113:source/os_rios/cpufunctions.c ****    *
 114:source/os_rios/cpufunctions.c ****    * UCSRnc - USART Control and Status Register C
 115:source/os_rios/cpufunctions.c ****    *          -> UMSELn bit controls USART mode
 116:source/os_rios/cpufunctions.c ****    * UCSRnA - USART Control and Status Register A
 117:source/os_rios/cpufunctions.c ****    *          -> U2Xn bit controls doublespeed
 118:source/os_rios/cpufunctions.c ****    * UBRRn  - USART Baud Rate Register
 119:source/os_rios/cpufunctions.c ****    *
 120:source/os_rios/cpufunctions.c ****    * Recommended baud rate settings from the datasheet:
 121:source/os_rios/cpufunctions.c ****    *
 122:source/os_rios/cpufunctions.c ****    * 9600 kbps - U2Xn = 1, UBRRn = 12 with fosc = 1 Mhz. (0.2 % error)
 123:source/os_rios/cpufunctions.c ****    * Selection criterion: Minimal error in data receiving using available clock.
 124:source/os_rios/cpufunctions.c ****    *
 125:source/os_rios/cpufunctions.c ****    * Our Baud caculation: UBRRn = (fosc/8*BAUD) - 1
 126:source/os_rios/cpufunctions.c ****    *                            = (1000000/8*9600) - 1
 127:source/os_rios/cpufunctions.c ****    *                            ~ 12
 128:source/os_rios/cpufunctions.c ****    *
 129:source/os_rios/cpufunctions.c ****    * Required settings for the TFmini LIDAR Sensor:
 130:source/os_rios/cpufunctions.c ****    *
 131:source/os_rios/cpufunctions.c ****    * Data bits - 8, Stop bits - 1, Parity Check - None
 132:source/os_rios/cpufunctions.c ****    */
 133:source/os_rios/cpufunctions.c **** 
 134:source/os_rios/cpufunctions.c ****   // Set 8 bit data
 135:source/os_rios/cpufunctions.c ****   UCSR0C = UCSR0C | ((1<<UCSZ01) | (1<<UCSZ00));
 283               		.stabn	68,0,135,.LM22-.LFBB5
 284               	.LM22:
 285 008e E2EC      		ldi r30,lo8(-62)
 286 0090 F0E0      		ldi r31,0
 287 0092 8081      		ld r24,Z
 288 0094 8660      		ori r24,lo8(6)
 289 0096 8083      		st Z,r24
 136:source/os_rios/cpufunctions.c **** 
 137:source/os_rios/cpufunctions.c ****   // Set baud rate High and Low byte in UBBR
 138:source/os_rios/cpufunctions.c ****   UBRR0H = (CALCULATEDUBBR>>8);
 290               		.stabn	68,0,138,.LM23-.LFBB5
 291               	.LM23:
 292 0098 1092 C500 		sts 197,__zero_reg__
 139:source/os_rios/cpufunctions.c ****   UBRR0L =  CALCULATEDUBBR;
 293               		.stabn	68,0,139,.LM24-.LFBB5
 294               	.LM24:
 295 009c 89E1      		ldi r24,lo8(25)
 296 009e 8093 C400 		sts 196,r24
 140:source/os_rios/cpufunctions.c **** 
 141:source/os_rios/cpufunctions.c ****   // Enable USART transmit and receive
 142:source/os_rios/cpufunctions.c ****   UCSR0B = (1<<TXEN0) | (1<<RXEN0) | (1<<RXCIE0);
 297               		.stabn	68,0,142,.LM25-.LFBB5
 298               	.LM25:
 299 00a2 88E9      		ldi r24,lo8(-104)
 300 00a4 8093 C100 		sts 193,r24
 301 00a8 0895      		ret
 302               		.size	hardwareserialsetup, .-hardwareserialsetup
 303               	.Lscope5:
 304               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 305               		.stabd	78,0,0
 306               		.stabs	"softwareserialsetup:F(0,49)",36,0,145,softwareserialsetup
 307               	.global	softwareserialsetup
 308               		.type	softwareserialsetup, @function
 309               	softwareserialsetup:
 310               		.stabd	46,0,0
 143:source/os_rios/cpufunctions.c **** }
 144:source/os_rios/cpufunctions.c **** 
 145:source/os_rios/cpufunctions.c **** void softwareserialsetup(void){
 311               		.stabn	68,0,145,.LM26-.LFBB6
 312               	.LM26:
 313               	.LFBB6:
 314               	/* prologue: function */
 315               	/* frame size = 0 */
 316               	/* stack size = 0 */
 317               	.L__stack_usage = 0
 146:source/os_rios/cpufunctions.c ****   /* Software Serial Communication UASRT setup
 147:source/os_rios/cpufunctions.c ****    * -----------------------------------------
 148:source/os_rios/cpufunctions.c ****    *
 149:source/os_rios/cpufunctions.c ****    * The Arduino UNO has only one hardware UART. We will need another one for
 150:source/os_rios/cpufunctions.c ****    * debugging. Therefore we will need to emulate it and build a quick drver
 151:source/os_rios/cpufunctions.c ****    * that will allow us to transmit data while the RX pin is receiving. We can
 152:source/os_rios/cpufunctions.c ****    * use PORTB4 PIN 12 as software serial pin. Lets set that to high (IDLE).
 153:source/os_rios/cpufunctions.c ****    * Here is how a UART data frame with data 0xAA, a start, a stop bit and
 154:source/os_rios/cpufunctions.c ****    * no parity would look like for the Arduino:
 155:source/os_rios/cpufunctions.c ****    *
 156:source/os_rios/cpufunctions.c ****    *    IDLE | start bit |          8 data bits          |  stop bit | IDLE
 157:source/os_rios/cpufunctions.c ****    *    -------------------------------------------------------------------
 158:source/os_rios/cpufunctions.c ****    *
 159:source/os_rios/cpufunctions.c ****    *      1                1       1       1       1           1        1
 160:source/os_rios/cpufunctions.c ****    *    -----|           |---|   |---|   |---|   |---|   |-----------|-----
 161:source/os_rios/cpufunctions.c ****    *         |           |   |   |   |   |   |   |   |   |
 162:source/os_rios/cpufunctions.c ****    *         |           |   |   |   |   |   |   |   |   |
 163:source/os_rios/cpufunctions.c ****    *         |-----------|   |---|   |---|   |---|   |---|
 164:source/os_rios/cpufunctions.c ****    *               0           0       0       0       0
 165:source/os_rios/cpufunctions.c ****    *
 166:source/os_rios/cpufunctions.c ****    * The BUAD rate we want is 9600. That means we have 9600 bits per second.
 167:source/os_rios/cpufunctions.c ****    * That means 1 bit is transferred every (1 second/ 9600 bits) ~104 us.
 168:source/os_rios/cpufunctions.c ****    * We are clocked at 4000000 Hz. Each "tick" is 0.25 us. So this should be not
 169:source/os_rios/cpufunctions.c ****    * be a big deal to do with a regular pin if we just turn it ON and OFF to
 170:source/os_rios/cpufunctions.c ****    * simulate serial data. We will be using PORTB4 to do this which means
 171:source/os_rios/cpufunctions.c ****    * PIN 12 on the Arduino UNO board and a TTL USB driver on an external bread
 172:source/os_rios/cpufunctions.c ****    * board connected to a laptop to see the output.
 173:source/os_rios/cpufunctions.c ****    */
 174:source/os_rios/cpufunctions.c **** 
 175:source/os_rios/cpufunctions.c ****   /* Set the direction of PORTB4 to OUTPUT and hold it HIGH (IDLE) */
 176:source/os_rios/cpufunctions.c ****   DDRB  |= (1<<DDB4);
 318               		.stabn	68,0,176,.LM27-.LFBB6
 319               	.LM27:
 320 00aa 249A      		sbi 0x4,4
 177:source/os_rios/cpufunctions.c ****   PORTB |= (1<<PORTB4);
 321               		.stabn	68,0,177,.LM28-.LFBB6
 322               	.LM28:
 323 00ac 2C9A      		sbi 0x5,4
 324 00ae 0895      		ret
 325               		.size	softwareserialsetup, .-softwareserialsetup
 326               	.Lscope6:
 327               		.stabs	"",36,0,0,.Lscope6-.LFBB6
 328               		.stabd	78,0,0
 329               		.stabs	"faultledsetup:F(0,49)",36,0,180,faultledsetup
 330               	.global	faultledsetup
 331               		.type	faultledsetup, @function
 332               	faultledsetup:
 333               		.stabd	46,0,0
 178:source/os_rios/cpufunctions.c **** }
 179:source/os_rios/cpufunctions.c **** 
 180:source/os_rios/cpufunctions.c **** void faultledsetup(void){
 334               		.stabn	68,0,180,.LM29-.LFBB7
 335               	.LM29:
 336               	.LFBB7:
 337               	/* prologue: function */
 338               	/* frame size = 0 */
 339               	/* stack size = 0 */
 340               	.L__stack_usage = 0
 181:source/os_rios/cpufunctions.c ****   /* let us set up the built-in LED to light up when there is a fault */
 182:source/os_rios/cpufunctions.c ****   DDRB |= (1<<DDB5);     // Make the pin direction out
 341               		.stabn	68,0,182,.LM30-.LFBB7
 342               	.LM30:
 343 00b0 259A      		sbi 0x4,5
 183:source/os_rios/cpufunctions.c ****   PORTB &= ~(1<<PORTB5); // Turn it off so that it can be turned on when faulted
 344               		.stabn	68,0,183,.LM31-.LFBB7
 345               	.LM31:
 346 00b2 2D98      		cbi 0x5,5
 347 00b4 0895      		ret
 348               		.size	faultledsetup, .-faultledsetup
 349               	.Lscope7:
 350               		.stabs	"",36,0,0,.Lscope7-.LFBB7
 351               		.stabd	78,0,0
 352               		.stabs	"",100,0,0,.Letext0
 353               	.Letext0:
 354               		.ident	"GCC: (GNU) 5.4.0"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 cpufunctions.c
     /tmp/ccr9LCIT.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccr9LCIT.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccr9LCIT.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccr9LCIT.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccr9LCIT.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccr9LCIT.s:107    .text:0000000000000000 clocksetup
     /tmp/ccr9LCIT.s:134    .text:000000000000000e pwmtimer2setup
     /tmp/ccr9LCIT.s:176    .text:0000000000000032 LIDARreadtimer0setup
     /tmp/ccr9LCIT.s:219    .text:0000000000000054 propulsiontimer1setup
     /tmp/ccr9LCIT.s:274    .text:000000000000008e hardwareserialsetup
     /tmp/ccr9LCIT.s:309    .text:00000000000000aa softwareserialsetup
     /tmp/ccr9LCIT.s:332    .text:00000000000000b0 faultledsetup

NO UNDEFINED SYMBOLS

   1               		.file	"LIDARBOT.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/manu/github/arduino/LIDARBOT/",100,0,2,.Ltext0
   8               		.stabs	"source/application/LIDARBOT.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=r(0,2);0;127;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"__int128:t(0,6)=@s128;r(0,6);02000000000000000000000000000000000000000000;0177777777777777
  18               		.stabs	"__int128 unsigned:t(0,7)=@s128;r(0,7);0;03777777777777777777777777777777777777777777;",128
  19               		.stabs	"long long int:t(0,8)=@s64;r(0,8);01000000000000000000000;00777777777777777777777;",128,0,0
  20               		.stabs	"long long unsigned int:t(0,9)=@s64;r(0,9);0;01777777777777777777777;",128,0,0,0
  21               		.stabs	"short int:t(0,10)=r(0,10);-32768;32767;",128,0,0,0
  22               		.stabs	"short unsigned int:t(0,11)=r(0,11);0;0177777;",128,0,0,0
  23               		.stabs	"signed char:t(0,12)=@s8;r(0,12);-128;127;",128,0,0,0
  24               		.stabs	"unsigned char:t(0,13)=@s8;r(0,13);0;255;",128,0,0,0
  25               		.stabs	"float:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"double:t(0,15)=r(0,1);4;0;",128,0,0,0
  27               		.stabs	"long double:t(0,16)=r(0,1);4;0;",128,0,0,0
  28               		.stabs	"short _Fract:t(0,17)=r(0,1);1;0;",128,0,0,0
  29               		.stabs	"_Fract:t(0,18)=r(0,1);2;0;",128,0,0,0
  30               		.stabs	"long _Fract:t(0,19)=r(0,1);4;0;",128,0,0,0
  31               		.stabs	"long long _Fract:t(0,20)=r(0,1);8;0;",128,0,0,0
  32               		.stabs	"unsigned short _Fract:t(0,21)=r(0,1);1;0;",128,0,0,0
  33               		.stabs	"unsigned _Fract:t(0,22)=r(0,1);2;0;",128,0,0,0
  34               		.stabs	"unsigned long _Fract:t(0,23)=r(0,1);4;0;",128,0,0,0
  35               		.stabs	"unsigned long long _Fract:t(0,24)=r(0,1);8;0;",128,0,0,0
  36               		.stabs	"_Sat short _Fract:t(0,25)=r(0,1);1;0;",128,0,0,0
  37               		.stabs	"_Sat _Fract:t(0,26)=r(0,1);2;0;",128,0,0,0
  38               		.stabs	"_Sat long _Fract:t(0,27)=r(0,1);4;0;",128,0,0,0
  39               		.stabs	"_Sat long long _Fract:t(0,28)=r(0,1);8;0;",128,0,0,0
  40               		.stabs	"_Sat unsigned short _Fract:t(0,29)=r(0,1);1;0;",128,0,0,0
  41               		.stabs	"_Sat unsigned _Fract:t(0,30)=r(0,1);2;0;",128,0,0,0
  42               		.stabs	"_Sat unsigned long _Fract:t(0,31)=r(0,1);4;0;",128,0,0,0
  43               		.stabs	"_Sat unsigned long long _Fract:t(0,32)=r(0,1);8;0;",128,0,0,0
  44               		.stabs	"short _Accum:t(0,33)=r(0,1);2;0;",128,0,0,0
  45               		.stabs	"_Accum:t(0,34)=r(0,1);4;0;",128,0,0,0
  46               		.stabs	"long _Accum:t(0,35)=r(0,1);8;0;",128,0,0,0
  47               		.stabs	"long long _Accum:t(0,36)=r(0,1);8;0;",128,0,0,0
  48               		.stabs	"unsigned short _Accum:t(0,37)=r(0,1);2;0;",128,0,0,0
  49               		.stabs	"unsigned _Accum:t(0,38)=r(0,1);4;0;",128,0,0,0
  50               		.stabs	"unsigned long _Accum:t(0,39)=r(0,1);8;0;",128,0,0,0
  51               		.stabs	"unsigned long long _Accum:t(0,40)=r(0,1);8;0;",128,0,0,0
  52               		.stabs	"_Sat short _Accum:t(0,41)=r(0,1);2;0;",128,0,0,0
  53               		.stabs	"_Sat _Accum:t(0,42)=r(0,1);4;0;",128,0,0,0
  54               		.stabs	"_Sat long _Accum:t(0,43)=r(0,1);8;0;",128,0,0,0
  55               		.stabs	"_Sat long long _Accum:t(0,44)=r(0,1);8;0;",128,0,0,0
  56               		.stabs	"_Sat unsigned short _Accum:t(0,45)=r(0,1);2;0;",128,0,0,0
  57               		.stabs	"_Sat unsigned _Accum:t(0,46)=r(0,1);4;0;",128,0,0,0
  58               		.stabs	"_Sat unsigned long _Accum:t(0,47)=r(0,1);8;0;",128,0,0,0
  59               		.stabs	"_Sat unsigned long long _Accum:t(0,48)=r(0,1);8;0;",128,0,0,0
  60               		.stabs	"void:t(0,49)=(0,49)",128,0,0,0
  61               		.stabs	"source/application/LIDARBOT.h",130,0,0,0
  62               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/avr/io.h",130,0,0,0
  63               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/avr/sfr_defs.h",130,0,0,0
  64               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/inttypes.h",130,0,0,0
  65               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/stdint.h",130,0,0,0
  66               		.stabs	"int8_t:t(5,1)=(0,12)",128,0,125,0
  67               		.stabs	"uint8_t:t(5,2)=(0,13)",128,0,126,0
  68               		.stabs	"int16_t:t(5,3)=(0,1)",128,0,127,0
  69               		.stabs	"uint16_t:t(5,4)=(0,4)",128,0,128,0
  70               		.stabs	"int32_t:t(5,5)=(0,3)",128,0,129,0
  71               		.stabs	"uint32_t:t(5,6)=(0,5)",128,0,130,0
  72               		.stabs	"int64_t:t(5,7)=(0,8)",128,0,132,0
  73               		.stabs	"uint64_t:t(5,8)=(0,9)",128,0,133,0
  74               		.stabs	"intptr_t:t(5,9)=(5,3)",128,0,146,0
  75               		.stabs	"uintptr_t:t(5,10)=(5,4)",128,0,151,0
  76               		.stabs	"int_least8_t:t(5,11)=(5,1)",128,0,163,0
  77               		.stabs	"uint_least8_t:t(5,12)=(5,2)",128,0,168,0
  78               		.stabs	"int_least16_t:t(5,13)=(5,3)",128,0,173,0
  79               		.stabs	"uint_least16_t:t(5,14)=(5,4)",128,0,178,0
  80               		.stabs	"int_least32_t:t(5,15)=(5,5)",128,0,183,0
  81               		.stabs	"uint_least32_t:t(5,16)=(5,6)",128,0,188,0
  82               		.stabs	"int_least64_t:t(5,17)=(5,7)",128,0,196,0
  83               		.stabs	"uint_least64_t:t(5,18)=(5,8)",128,0,203,0
  84               		.stabs	"int_fast8_t:t(5,19)=(5,1)",128,0,217,0
  85               		.stabs	"uint_fast8_t:t(5,20)=(5,2)",128,0,222,0
  86               		.stabs	"int_fast16_t:t(5,21)=(5,3)",128,0,227,0
  87               		.stabs	"uint_fast16_t:t(5,22)=(5,4)",128,0,232,0
  88               		.stabs	"int_fast32_t:t(5,23)=(5,5)",128,0,237,0
  89               		.stabs	"uint_fast32_t:t(5,24)=(5,6)",128,0,242,0
  90               		.stabs	"int_fast64_t:t(5,25)=(5,7)",128,0,250,0
  91               		.stabs	"uint_fast64_t:t(5,26)=(5,8)",128,0,257,0
  92               		.stabs	"intmax_t:t(5,27)=(5,7)",128,0,277,0
  93               		.stabs	"uintmax_t:t(5,28)=(5,8)",128,0,282,0
  94               		.stabn	162,0,0,0
  95               		.stabs	"int_farptr_t:t(4,1)=(5,5)",128,0,77,0
  96               		.stabs	"uint_farptr_t:t(4,2)=(5,6)",128,0,81,0
  97               		.stabn	162,0,0,0
  98               		.stabn	162,0,0,0
  99               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/avr/fuse.h",130,0,0,0
 100               		.stabs	"__fuse_t:t(6,1)=(6,2)=s3low:(0,13),0,8;high:(0,13),8,8;extended:(0,13),16,8;;",128,0,244,0
 101               		.stabn	162,0,0,0
 102               		.stabn	162,0,0,0
 103               		.stabs	"source/application/../os/USART.h",130,0,0,0
 104               		.stabs	"source/application/../os/../drivers/LIDAR_driver.h",130,0,0,0
 105               		.stabs	"LIDARMODULESTRUCT:T(8,1)=s9headbyte1:(0,13),0,8;headbyte2:(0,13),8,8;distanceLow:(0,13),16
 106               		.stabs	"LIDAR:t(8,2)=(8,1)",128,0,26,0
 107               		.stabs	"OBJECTPROXIMITYSTRUCT:T(8,3)=s3proximity:(0,4),0,16;valid:(0,13),16,8;;",128,0,0,0
 108               		.stabs	"OBJECT:t(8,4)=(8,3)",128,0,35,0
 109               		.stabn	162,0,0,0
 110               		.stabs	"bufferStatus:T(7,1)=eBUFFER_OK:0,BUFFER_EMPTY:1,BUFFER_FULL:2,;",128,0,0,0
 111               		.stabs	"Buffer:T(7,2)=s1026data:(7,3)=ar(7,4)=r(7,4);0;0177777;;0;1023;(0,13),0,8192;readindex:(0,
 112               		.stabs	"Buffer:t(7,5)=(7,2)",128,0,34,0
 113               		.stabn	162,0,0,0
 114               		.stabn	162,0,0,0
 115               		.stabs	"initbot:F(0,49)",36,0,3,initbot
 116               	.global	initbot
 117               		.type	initbot, @function
 118               	initbot:
 119               		.stabd	46,0,0
   1:source/application/LIDARBOT.c **** #include "LIDARBOT.h"
   2:source/application/LIDARBOT.c **** 
   3:source/application/LIDARBOT.c **** void initbot(){
 120               		.stabn	68,0,3,.LM0-.LFBB1
 121               	.LM0:
 122               	.LFBB1:
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               	/* stack size = 0 */
 126               	.L__stack_usage = 0
   4:source/application/LIDARBOT.c ****   /* Initialize all robot functions */
   5:source/application/LIDARBOT.c ****   clocksetup();  // Master clock setup
 127               		.stabn	68,0,5,.LM1-.LFBB1
 128               	.LM1:
 129 0000 0E94 0000 		call clocksetup
   6:source/application/LIDARBOT.c ****   usartinit();   // Communication setup
 130               		.stabn	68,0,6,.LM2-.LFBB1
 131               	.LM2:
 132 0004 0E94 0000 		call usartinit
   7:source/application/LIDARBOT.c ****   lidarinit();   // LIDAR read setup
 133               		.stabn	68,0,7,.LM3-.LFBB1
 134               	.LM3:
 135 0008 0E94 0000 		call lidarinit
   8:source/application/LIDARBOT.c ****   motorinit();   // Propulsion setup
 136               		.stabn	68,0,8,.LM4-.LFBB1
 137               	.LM4:
 138 000c 0C94 0000 		jmp motorinit
 139               		.size	initbot, .-initbot
 140               	.Lscope1:
 141               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 142               		.stabd	78,0,0
 143               		.section	.text.startup,"ax",@progbits
 144               		.stabs	"main:F(0,1)",36,0,11,main
 145               	.global	main
 146               		.type	main, @function
 147               	main:
 148               		.stabd	46,0,0
   9:source/application/LIDARBOT.c **** }
  10:source/application/LIDARBOT.c **** 
  11:source/application/LIDARBOT.c **** int main(){
 149               		.stabn	68,0,11,.LM5-.LFBB2
 150               	.LM5:
 151               	.LFBB2:
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
  12:source/application/LIDARBOT.c ****   // Initialize BOT
  13:source/application/LIDARBOT.c ****   initbot();
 156               		.stabn	68,0,13,.LM6-.LFBB2
 157               	.LM6:
 158 0000 0E94 0000 		call initbot
 159               	.LBB4:
 160               	.LBB5:
 161               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h",132,0,0,.Ltext1
 162               	.Ltext1:
   1:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    All rights reserved.
   5:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
   6:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
   9:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  12:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      the documentation and/or other materials provided with the
  15:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      distribution.
  16:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  17:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      from this software without specific prior written permission.
  20:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  21:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  33:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /* $Id$ */
  34:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  35:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  38:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #ifndef __DOXYGEN__
  39:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #  endif
  42:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  44:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #include <inttypes.h>
  45:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #include <util/delay_basic.h>
  46:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #include <math.h>
  47:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  48:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /** \file */
  49:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \code
  51:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     #include <util/delay.h>
  54:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \endcode
  55:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  56:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     used.
  60:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  61:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     convenience functions where actual time values can be specified
  64:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  70:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     routines linked into the application.
  78:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  79:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  83:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** */
  84:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  85:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
  89:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  90:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #ifndef F_CPU
  91:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /** \ingroup util_delay
  94:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \def F_CPU
  95:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \brief CPU frequency in Hz
  96:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  97:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 103:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     integer value.
 107:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****  */
 108:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** # define F_CPU 1000000UL
 109:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
 110:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 111:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #ifndef __OPTIMIZE__
 112:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
 114:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 115:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   __STDC_HOSTED__
 118:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #  include <math.h>
 119:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
 120:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 121:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /**
 122:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \ingroup util_delay
 123:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 124:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 126:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 129:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 131:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    user will not be informed about decreased resolution.
 136:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 137:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    no delay i.e., 0ms.
 141:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 142:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    microseconds of delay.
 146:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 147:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    respectively.
 151:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 152:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \note
 153:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 154:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    The implementation of _delay_ms() based on
 155:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    must be defined before including this header file. Also, the
 159:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    not available to the compiler then.
 163:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 164:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****  */
 165:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** void
 166:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** _delay_ms(double __ms)
 167:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** {
 168:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	double __tmp ;
 169:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   __STDC_HOSTED__
 172:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	uint32_t __ticks_dc;
 173:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 176:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 179:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 182:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#else
 183:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		//round up by default
 184:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#endif
 186:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 187:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 163               		.stabn	68,0,187,.LM7-.LFBB2
 164               	.LM7:
 165 0004 2FEF      		ldi r18,lo8(1599999)
 166 0006 89E6      		ldi r24,hi8(1599999)
 167 0008 98E1      		ldi r25,hlo8(1599999)
 168 000a 2150      	1:	subi r18,1
 169 000c 8040      		sbci r24,0
 170 000e 9040      		sbci r25,0
 171 0010 01F4      		brne 1b
 172 0012 00C0      		rjmp .
 173 0014 0000      		nop
 174               	.LBE5:
 175               	.LBE4:
 176               		.stabs	"source/application/LIDARBOT.c",132,0,0,.Ltext2
 177               	.Ltext2:
  14:source/application/LIDARBOT.c ****   // A small delay to give the bot owner time to step away
  15:source/application/LIDARBOT.c ****   _delay_ms(2000);
  16:source/application/LIDARBOT.c **** 
  17:source/application/LIDARBOT.c ****   // Enable global interrupts - Bot Key ON
  18:source/application/LIDARBOT.c ****   sei();
 178               		.stabn	68,0,18,.LM8-.LFBB2
 179               	.LM8:
 180               	/* #APP */
 181               	 ;  18 "source/application/LIDARBOT.c" 1
 182 0016 7894      		sei
 183               	 ;  0 "" 2
 184               	/* #NOAPP */
 185               	.L3:
 186 0018 00C0      		rjmp .L3
 187               		.size	main, .-main
 188               	.Lscope2:
 189               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 190               		.stabd	78,0,0
 191               		.text
 192               		.stabs	"__vector_18:F(0,49)",36,0,32,__vector_18
 193               	.global	__vector_18
 194               		.type	__vector_18, @function
 195               	__vector_18:
 196               		.stabd	46,0,0
  19:source/application/LIDARBOT.c **** 
  20:source/application/LIDARBOT.c ****   while (1) {
  21:source/application/LIDARBOT.c ****     /* The bot uses an interrupt driven operating system to do its tasks
  22:source/application/LIDARBOT.c ****      * which are to read LIDAR data over UART and decide if it needs to Turn
  23:source/application/LIDARBOT.c ****      * turn right if need be. Hence, it will keep repeating this instruction.
  24:source/application/LIDARBOT.c ****      */
  25:source/application/LIDARBOT.c ****   }
  26:source/application/LIDARBOT.c **** }
  27:source/application/LIDARBOT.c **** 
  28:source/application/LIDARBOT.c **** /******************************************************************************/
  29:source/application/LIDARBOT.c **** /*                     INTERRUPT SERVICE ROUTINES                             */
  30:source/application/LIDARBOT.c **** /******************************************************************************/
  31:source/application/LIDARBOT.c **** /* USART RECEIVE TASK */
  32:source/application/LIDARBOT.c **** ISR(USART_RX_vect){ /* Asynchronous Hardware Interrupt */
 197               		.stabn	68,0,32,.LM9-.LFBB3
 198               	.LM9:
 199               	.LFBB3:
 200 0010 1F92      		push r1
 201 0012 0F92      		push r0
 202 0014 0FB6      		in r0,__SREG__
 203 0016 0F92      		push r0
 204 0018 1124      		clr __zero_reg__
 205 001a 2F93      		push r18
 206 001c 3F93      		push r19
 207 001e 4F93      		push r20
 208 0020 5F93      		push r21
 209 0022 6F93      		push r22
 210 0024 7F93      		push r23
 211 0026 8F93      		push r24
 212 0028 9F93      		push r25
 213 002a AF93      		push r26
 214 002c BF93      		push r27
 215 002e EF93      		push r30
 216 0030 FF93      		push r31
 217               	/* prologue: Signal */
 218               	/* frame size = 0 */
 219               	/* stack size = 15 */
 220               	.L__stack_usage = 15
  33:source/application/LIDARBOT.c ****   /* We want our interrupt service routine to be quick as possible. Which is why
  34:source/application/LIDARBOT.c ****    * all this routine will do is write to the ring buffer and get out. However,
  35:source/application/LIDARBOT.c ****    * we need our cpu to be quicker so that elements from that buffer are emptied
  36:source/application/LIDARBOT.c ****    * faster than this ISR can populate the buffer. This was one of the prime
  37:source/application/LIDARBOT.c ****    * reasons why the chosen clock was 4 Mhz.
  38:source/application/LIDARBOT.c ****    */
  39:source/application/LIDARBOT.c ****   if((rxBufferWrite() != BUFFER_OK)){
 221               		.stabn	68,0,39,.LM10-.LFBB3
 222               	.LM10:
 223 0032 0E94 0000 		call rxBufferWrite
 224 0036 892B      		or r24,r25
 225 0038 01F0      		breq .L5
  40:source/application/LIDARBOT.c ****     readLIDAR();
 226               		.stabn	68,0,40,.LM11-.LFBB3
 227               	.LM11:
 228 003a 0E94 0000 		call readLIDAR
  41:source/application/LIDARBOT.c ****     rxBufferWrite();
 229               		.stabn	68,0,41,.LM12-.LFBB3
 230               	.LM12:
 231 003e 0E94 0000 		call rxBufferWrite
 232               	.L5:
 233               	/* epilogue start */
  42:source/application/LIDARBOT.c ****   }
  43:source/application/LIDARBOT.c **** }
 234               		.stabn	68,0,43,.LM13-.LFBB3
 235               	.LM13:
 236 0042 FF91      		pop r31
 237 0044 EF91      		pop r30
 238 0046 BF91      		pop r27
 239 0048 AF91      		pop r26
 240 004a 9F91      		pop r25
 241 004c 8F91      		pop r24
 242 004e 7F91      		pop r23
 243 0050 6F91      		pop r22
 244 0052 5F91      		pop r21
 245 0054 4F91      		pop r20
 246 0056 3F91      		pop r19
 247 0058 2F91      		pop r18
 248 005a 0F90      		pop r0
 249 005c 0FBE      		out __SREG__,r0
 250 005e 0F90      		pop r0
 251 0060 1F90      		pop r1
 252 0062 1895      		reti
 253               		.size	__vector_18, .-__vector_18
 254               	.Lscope3:
 255               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 256               		.stabd	78,0,0
 257               		.stabs	"__vector_14:F(0,49)",36,0,46,__vector_14
 258               	.global	__vector_14
 259               		.type	__vector_14, @function
 260               	__vector_14:
 261               		.stabd	46,0,0
  44:source/application/LIDARBOT.c **** 
  45:source/application/LIDARBOT.c **** /* USART BUFFER PROCESSING TASK */
  46:source/application/LIDARBOT.c **** ISR(TIMER0_COMPA_vect){ /* 320 us SOFTWARE INTERRUPT TASK RATE */
 262               		.stabn	68,0,46,.LM14-.LFBB4
 263               	.LM14:
 264               	.LFBB4:
 265 0064 1F92      		push r1
 266 0066 0F92      		push r0
 267 0068 0FB6      		in r0,__SREG__
 268 006a 0F92      		push r0
 269 006c 1124      		clr __zero_reg__
 270 006e 2F93      		push r18
 271 0070 3F93      		push r19
 272 0072 4F93      		push r20
 273 0074 5F93      		push r21
 274 0076 6F93      		push r22
 275 0078 7F93      		push r23
 276 007a 8F93      		push r24
 277 007c 9F93      		push r25
 278 007e AF93      		push r26
 279 0080 BF93      		push r27
 280 0082 EF93      		push r30
 281 0084 FF93      		push r31
 282               	/* prologue: Signal */
 283               	/* frame size = 0 */
 284               	/* stack size = 15 */
 285               	.L__stack_usage = 15
  47:source/application/LIDARBOT.c ****   /* Here we wait until there are atleast 50 bytes or close to 3 frames are in
  48:source/application/LIDARBOT.c ****    * the buffer to start reading. This method helps not reading the buffer
  49:source/application/LIDARBOT.c ****    * when there is no data and also keeps the interrupt time short.
  50:source/application/LIDARBOT.c ****    */
  51:source/application/LIDARBOT.c ****   if (buffercount>50) {
 286               		.stabn	68,0,51,.LM15-.LFBB4
 287               	.LM15:
 288 0086 8091 0000 		lds r24,buffercount
 289 008a 9091 0000 		lds r25,buffercount+1
 290 008e C397      		sbiw r24,51
 291 0090 00F0      		brlo .L10
  52:source/application/LIDARBOT.c ****     readLIDAR();
 292               		.stabn	68,0,52,.LM16-.LFBB4
 293               	.LM16:
 294 0092 0E94 0000 		call readLIDAR
 295               	.L10:
 296               	/* epilogue start */
  53:source/application/LIDARBOT.c ****   }
  54:source/application/LIDARBOT.c **** }
 297               		.stabn	68,0,54,.LM17-.LFBB4
 298               	.LM17:
 299 0096 FF91      		pop r31
 300 0098 EF91      		pop r30
 301 009a BF91      		pop r27
 302 009c AF91      		pop r26
 303 009e 9F91      		pop r25
 304 00a0 8F91      		pop r24
 305 00a2 7F91      		pop r23
 306 00a4 6F91      		pop r22
 307 00a6 5F91      		pop r21
 308 00a8 4F91      		pop r20
 309 00aa 3F91      		pop r19
 310 00ac 2F91      		pop r18
 311 00ae 0F90      		pop r0
 312 00b0 0FBE      		out __SREG__,r0
 313 00b2 0F90      		pop r0
 314 00b4 1F90      		pop r1
 315 00b6 1895      		reti
 316               		.size	__vector_14, .-__vector_14
 317               	.Lscope4:
 318               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 319               		.stabd	78,0,0
 320               		.stabs	"__vector_11:F(0,49)",36,0,57,__vector_11
 321               	.global	__vector_11
 322               		.type	__vector_11, @function
 323               	__vector_11:
 324               		.stabd	46,0,0
  55:source/application/LIDARBOT.c **** 
  56:source/application/LIDARBOT.c **** /* PROPULSION/NAVIGATION TASK */
  57:source/application/LIDARBOT.c **** ISR(TIMER1_COMPA_vect){ /* ~ 500 ms SOFTWARE INTERRUPT TASK RATE */
 325               		.stabn	68,0,57,.LM18-.LFBB5
 326               	.LM18:
 327               	.LFBB5:
 328 00b8 1F92      		push r1
 329 00ba 0F92      		push r0
 330 00bc 0FB6      		in r0,__SREG__
 331 00be 0F92      		push r0
 332 00c0 1124      		clr __zero_reg__
 333 00c2 2F93      		push r18
 334 00c4 3F93      		push r19
 335 00c6 4F93      		push r20
 336 00c8 5F93      		push r21
 337 00ca 6F93      		push r22
 338 00cc 7F93      		push r23
 339 00ce 8F93      		push r24
 340 00d0 9F93      		push r25
 341 00d2 AF93      		push r26
 342 00d4 BF93      		push r27
 343 00d6 EF93      		push r30
 344 00d8 FF93      		push r31
 345               	/* prologue: Signal */
 346               	/* frame size = 0 */
 347               	/* stack size = 15 */
 348               	.L__stack_usage = 15
  58:source/application/LIDARBOT.c ****   /* We will have this ISR drive and steer for us. */
  59:source/application/LIDARBOT.c ****   navigate();
 349               		.stabn	68,0,59,.LM19-.LFBB5
 350               	.LM19:
 351 00da 0E94 0000 		call navigate
 352               	/* epilogue start */
  60:source/application/LIDARBOT.c **** }
 353               		.stabn	68,0,60,.LM20-.LFBB5
 354               	.LM20:
 355 00de FF91      		pop r31
 356 00e0 EF91      		pop r30
 357 00e2 BF91      		pop r27
 358 00e4 AF91      		pop r26
 359 00e6 9F91      		pop r25
 360 00e8 8F91      		pop r24
 361 00ea 7F91      		pop r23
 362 00ec 6F91      		pop r22
 363 00ee 5F91      		pop r21
 364 00f0 4F91      		pop r20
 365 00f2 3F91      		pop r19
 366 00f4 2F91      		pop r18
 367 00f6 0F90      		pop r0
 368 00f8 0FBE      		out __SREG__,r0
 369 00fa 0F90      		pop r0
 370 00fc 1F90      		pop r1
 371 00fe 1895      		reti
 372               		.size	__vector_11, .-__vector_11
 373               	.Lscope5:
 374               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 375               		.stabd	78,0,0
 376               		.comm	buffercount,2,1
 377               		.comm	rxBuffer,1026,1
 378               		.comm	obstacle,3,1
 379               		.comm	tfmini,9,1
 380               		.comm	botmoving,1,1
 381               		.stabs	"botmoving:G(0,13)",32,0,27,0
 382               		.stabs	"tfmini:G(0,50)=B(8,2)",32,0,29,0
 383               		.stabs	"obstacle:G(0,51)=B(8,4)",32,0,37,0
 384               		.stabs	"rxBuffer:G(0,52)=B(7,5)",32,0,37,0
 385               		.stabs	"buffercount:G(0,53)=B(0,4)",32,0,38,0
 386               		.stabs	"",100,0,0,.Letext0
 387               	.Letext0:
 388               		.ident	"GCC: (GNU) 5.4.0"
 389               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 LIDARBOT.c
     /tmp/cceV4ChW.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cceV4ChW.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cceV4ChW.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cceV4ChW.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cceV4ChW.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cceV4ChW.s:118    .text:0000000000000000 initbot
     /tmp/cceV4ChW.s:147    .text.startup:0000000000000000 main
     /tmp/cceV4ChW.s:195    .text:0000000000000010 __vector_18
     /tmp/cceV4ChW.s:260    .text:0000000000000064 __vector_14
                            *COM*:0000000000000002 buffercount
     /tmp/cceV4ChW.s:323    .text:00000000000000b8 __vector_11
                            *COM*:0000000000000402 rxBuffer
                            *COM*:0000000000000003 obstacle
                            *COM*:0000000000000009 tfmini
                            *COM*:0000000000000001 botmoving

UNDEFINED SYMBOLS
clocksetup
usartinit
lidarinit
motorinit
rxBufferWrite
readLIDAR
navigate
__do_clear_bss

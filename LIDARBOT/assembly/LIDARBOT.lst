   1               		.file	"LIDARBOT.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/manu/github/arduino/LIDARBOT/",100,0,2,.Ltext0
   8               		.stabs	"source/application/LIDARBOT.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=r(0,2);0;127;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"__int128:t(0,6)=@s128;r(0,6);02000000000000000000000000000000000000000000;0177777777777777
  18               		.stabs	"__int128 unsigned:t(0,7)=@s128;r(0,7);0;03777777777777777777777777777777777777777777;",128
  19               		.stabs	"long long int:t(0,8)=@s64;r(0,8);01000000000000000000000;00777777777777777777777;",128,0,0
  20               		.stabs	"long long unsigned int:t(0,9)=@s64;r(0,9);0;01777777777777777777777;",128,0,0,0
  21               		.stabs	"short int:t(0,10)=r(0,10);-32768;32767;",128,0,0,0
  22               		.stabs	"short unsigned int:t(0,11)=r(0,11);0;0177777;",128,0,0,0
  23               		.stabs	"signed char:t(0,12)=@s8;r(0,12);-128;127;",128,0,0,0
  24               		.stabs	"unsigned char:t(0,13)=@s8;r(0,13);0;255;",128,0,0,0
  25               		.stabs	"float:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"double:t(0,15)=r(0,1);4;0;",128,0,0,0
  27               		.stabs	"long double:t(0,16)=r(0,1);4;0;",128,0,0,0
  28               		.stabs	"short _Fract:t(0,17)=r(0,1);1;0;",128,0,0,0
  29               		.stabs	"_Fract:t(0,18)=r(0,1);2;0;",128,0,0,0
  30               		.stabs	"long _Fract:t(0,19)=r(0,1);4;0;",128,0,0,0
  31               		.stabs	"long long _Fract:t(0,20)=r(0,1);8;0;",128,0,0,0
  32               		.stabs	"unsigned short _Fract:t(0,21)=r(0,1);1;0;",128,0,0,0
  33               		.stabs	"unsigned _Fract:t(0,22)=r(0,1);2;0;",128,0,0,0
  34               		.stabs	"unsigned long _Fract:t(0,23)=r(0,1);4;0;",128,0,0,0
  35               		.stabs	"unsigned long long _Fract:t(0,24)=r(0,1);8;0;",128,0,0,0
  36               		.stabs	"_Sat short _Fract:t(0,25)=r(0,1);1;0;",128,0,0,0
  37               		.stabs	"_Sat _Fract:t(0,26)=r(0,1);2;0;",128,0,0,0
  38               		.stabs	"_Sat long _Fract:t(0,27)=r(0,1);4;0;",128,0,0,0
  39               		.stabs	"_Sat long long _Fract:t(0,28)=r(0,1);8;0;",128,0,0,0
  40               		.stabs	"_Sat unsigned short _Fract:t(0,29)=r(0,1);1;0;",128,0,0,0
  41               		.stabs	"_Sat unsigned _Fract:t(0,30)=r(0,1);2;0;",128,0,0,0
  42               		.stabs	"_Sat unsigned long _Fract:t(0,31)=r(0,1);4;0;",128,0,0,0
  43               		.stabs	"_Sat unsigned long long _Fract:t(0,32)=r(0,1);8;0;",128,0,0,0
  44               		.stabs	"short _Accum:t(0,33)=r(0,1);2;0;",128,0,0,0
  45               		.stabs	"_Accum:t(0,34)=r(0,1);4;0;",128,0,0,0
  46               		.stabs	"long _Accum:t(0,35)=r(0,1);8;0;",128,0,0,0
  47               		.stabs	"long long _Accum:t(0,36)=r(0,1);8;0;",128,0,0,0
  48               		.stabs	"unsigned short _Accum:t(0,37)=r(0,1);2;0;",128,0,0,0
  49               		.stabs	"unsigned _Accum:t(0,38)=r(0,1);4;0;",128,0,0,0
  50               		.stabs	"unsigned long _Accum:t(0,39)=r(0,1);8;0;",128,0,0,0
  51               		.stabs	"unsigned long long _Accum:t(0,40)=r(0,1);8;0;",128,0,0,0
  52               		.stabs	"_Sat short _Accum:t(0,41)=r(0,1);2;0;",128,0,0,0
  53               		.stabs	"_Sat _Accum:t(0,42)=r(0,1);4;0;",128,0,0,0
  54               		.stabs	"_Sat long _Accum:t(0,43)=r(0,1);8;0;",128,0,0,0
  55               		.stabs	"_Sat long long _Accum:t(0,44)=r(0,1);8;0;",128,0,0,0
  56               		.stabs	"_Sat unsigned short _Accum:t(0,45)=r(0,1);2;0;",128,0,0,0
  57               		.stabs	"_Sat unsigned _Accum:t(0,46)=r(0,1);4;0;",128,0,0,0
  58               		.stabs	"_Sat unsigned long _Accum:t(0,47)=r(0,1);8;0;",128,0,0,0
  59               		.stabs	"_Sat unsigned long long _Accum:t(0,48)=r(0,1);8;0;",128,0,0,0
  60               		.stabs	"void:t(0,49)=(0,49)",128,0,0,0
  61               		.stabs	"source/application/LIDARBOT.h",130,0,0,0
  62               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/avr/io.h",130,0,0,0
  63               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/avr/sfr_defs.h",130,0,0,0
  64               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/inttypes.h",130,0,0,0
  65               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/stdint.h",130,0,0,0
  66               		.stabs	"int8_t:t(5,1)=(0,12)",128,0,125,0
  67               		.stabs	"uint8_t:t(5,2)=(0,13)",128,0,126,0
  68               		.stabs	"int16_t:t(5,3)=(0,1)",128,0,127,0
  69               		.stabs	"uint16_t:t(5,4)=(0,4)",128,0,128,0
  70               		.stabs	"int32_t:t(5,5)=(0,3)",128,0,129,0
  71               		.stabs	"uint32_t:t(5,6)=(0,5)",128,0,130,0
  72               		.stabs	"int64_t:t(5,7)=(0,8)",128,0,132,0
  73               		.stabs	"uint64_t:t(5,8)=(0,9)",128,0,133,0
  74               		.stabs	"intptr_t:t(5,9)=(5,3)",128,0,146,0
  75               		.stabs	"uintptr_t:t(5,10)=(5,4)",128,0,151,0
  76               		.stabs	"int_least8_t:t(5,11)=(5,1)",128,0,163,0
  77               		.stabs	"uint_least8_t:t(5,12)=(5,2)",128,0,168,0
  78               		.stabs	"int_least16_t:t(5,13)=(5,3)",128,0,173,0
  79               		.stabs	"uint_least16_t:t(5,14)=(5,4)",128,0,178,0
  80               		.stabs	"int_least32_t:t(5,15)=(5,5)",128,0,183,0
  81               		.stabs	"uint_least32_t:t(5,16)=(5,6)",128,0,188,0
  82               		.stabs	"int_least64_t:t(5,17)=(5,7)",128,0,196,0
  83               		.stabs	"uint_least64_t:t(5,18)=(5,8)",128,0,203,0
  84               		.stabs	"int_fast8_t:t(5,19)=(5,1)",128,0,217,0
  85               		.stabs	"uint_fast8_t:t(5,20)=(5,2)",128,0,222,0
  86               		.stabs	"int_fast16_t:t(5,21)=(5,3)",128,0,227,0
  87               		.stabs	"uint_fast16_t:t(5,22)=(5,4)",128,0,232,0
  88               		.stabs	"int_fast32_t:t(5,23)=(5,5)",128,0,237,0
  89               		.stabs	"uint_fast32_t:t(5,24)=(5,6)",128,0,242,0
  90               		.stabs	"int_fast64_t:t(5,25)=(5,7)",128,0,250,0
  91               		.stabs	"uint_fast64_t:t(5,26)=(5,8)",128,0,257,0
  92               		.stabs	"intmax_t:t(5,27)=(5,7)",128,0,277,0
  93               		.stabs	"uintmax_t:t(5,28)=(5,8)",128,0,282,0
  94               		.stabn	162,0,0,0
  95               		.stabs	"int_farptr_t:t(4,1)=(5,5)",128,0,77,0
  96               		.stabs	"uint_farptr_t:t(4,2)=(5,6)",128,0,81,0
  97               		.stabn	162,0,0,0
  98               		.stabn	162,0,0,0
  99               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/avr/fuse.h",130,0,0,0
 100               		.stabs	"__fuse_t:t(6,1)=(6,2)=s3low:(0,13),0,8;high:(0,13),8,8;extended:(0,13),16,8;;",128,0,244,0
 101               		.stabn	162,0,0,0
 102               		.stabn	162,0,0,0
 103               		.stabs	"source/application/../os/USART.h",130,0,0,0
 104               		.stabs	"source/application/../os/../drivers/LIDAR_driver.h",130,0,0,0
 105               		.stabs	"LIDARMODULESTRUCT:T(8,1)=s9headbyte1:(0,13),0,8;headbyte2:(0,13),8,8;distanceLow:(0,13),16
 106               		.stabs	"LIDAR:t(8,2)=(8,1)",128,0,25,0
 107               		.stabs	"OBJECTPROXIMITYSTRUCT:T(8,3)=s3proximity:(0,4),0,16;valid:(0,13),16,8;;",128,0,0,0
 108               		.stabs	"OBJECT:t(8,4)=(8,3)",128,0,34,0
 109               		.stabn	162,0,0,0
 110               		.stabs	"bufferStatus:T(7,1)=eBUFFER_OK:0,BUFFER_EMPTY:1,BUFFER_FULL:2,;",128,0,0,0
 111               		.stabs	"Buffer:T(7,2)=s1026data:(7,3)=ar(7,4)=r(7,4);0;0177777;;0;1023;(0,13),0,8192;readindex:(0,
 112               		.stabs	"Buffer:t(7,5)=(7,2)",128,0,34,0
 113               		.stabn	162,0,0,0
 114               		.stabn	162,0,0,0
 115               		.stabs	"navigate:F(0,49)",36,0,3,navigate
 116               	.global	navigate
 117               		.type	navigate, @function
 118               	navigate:
 119               		.stabd	46,0,0
   1:source/application/LIDARBOT.c **** #include "LIDARBOT.h"
   2:source/application/LIDARBOT.c **** 
   3:source/application/LIDARBOT.c **** void navigate(void){
 120               		.stabn	68,0,3,.LM0-.LFBB1
 121               	.LM0:
 122               	.LFBB1:
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               	/* stack size = 0 */
 126               	.L__stack_usage = 0
   4:source/application/LIDARBOT.c ****   // BasicBot: See if there is anything ahead and mindlessly turn right
   5:source/application/LIDARBOT.c ****   if ((obstacle.valid == VALID) && (obstacle.proximity < 45) && (botmoving == 1)) {
 127               		.stabn	68,0,5,.LM1-.LFBB1
 128               	.LM1:
 129 0000 8091 0000 		lds r24,obstacle+2
 130 0004 8032      		cpi r24,lo8(32)
 131 0006 01F4      		brne .L2
 132               		.stabn	68,0,5,.LM2-.LFBB1
 133               	.LM2:
 134 0008 8091 0000 		lds r24,obstacle
 135 000c 9091 0000 		lds r25,obstacle+1
 136 0010 8D97      		sbiw r24,45
 137 0012 00F4      		brsh .L2
 138               		.stabn	68,0,5,.LM3-.LFBB1
 139               	.LM3:
 140 0014 8091 0000 		lds r24,botmoving
 141 0018 8130      		cpi r24,lo8(1)
 142 001a 01F4      		brne .L2
 143               	.L4:
   6:source/application/LIDARBOT.c ****     /* An obstacle lies ahead. Turn right and hope the bot is cleared it. */
   7:source/application/LIDARBOT.c ****     stop();
 144               		.stabn	68,0,7,.LM4-.LFBB1
 145               	.LM4:
 146 001c 0C94 0000 		jmp stop
 147               	.L2:
   8:source/application/LIDARBOT.c ****   }
   9:source/application/LIDARBOT.c ****   else if ((obstacle.valid == INVALID) && (botmoving == 1)) {
 148               		.stabn	68,0,9,.LM5-.LFBB1
 149               	.LM5:
 150 0020 8091 0000 		lds r24,obstacle+2
 151 0024 8F3F      		cpi r24,lo8(-1)
 152 0026 01F4      		brne .L3
 153               		.stabn	68,0,9,.LM6-.LFBB1
 154               	.LM6:
 155 0028 8091 0000 		lds r24,botmoving
 156 002c 8130      		cpi r24,lo8(1)
 157 002e 01F0      		breq .L4
 158               	.L3:
  10:source/application/LIDARBOT.c ****     /* The bot is blind. Poor reflectivity or other such reasons mentioned in the datasheet has
  11:source/application/LIDARBOT.c ****      * caused the lidar data to go bad whilst moving. Stop.
  12:source/application/LIDARBOT.c ****      */
  13:source/application/LIDARBOT.c ****     stop();
  14:source/application/LIDARBOT.c ****   }
  15:source/application/LIDARBOT.c ****   else if ((obstacle.valid == INVALID) && (botmoving == 0)) {
 159               		.stabn	68,0,15,.LM7-.LFBB1
 160               	.LM7:
 161 0030 8091 0000 		lds r24,obstacle+2
 162 0034 8F3F      		cpi r24,lo8(-1)
 163 0036 01F4      		brne .L5
 164               		.stabn	68,0,15,.LM8-.LFBB1
 165               	.LM8:
 166 0038 8091 0000 		lds r24,botmoving
 167 003c 8111      		cpse r24,__zero_reg__
 168 003e 00C0      		rjmp .L5
 169               	.L7:
  16:source/application/LIDARBOT.c ****     /* The bot is blind. Poor reflectivity or other such reasons mentioned in the datasheet has
  17:source/application/LIDARBOT.c ****      * caused the lidar data to go bad. Turn right and see if the data becomes better.
  18:source/application/LIDARBOT.c ****      */
  19:source/application/LIDARBOT.c ****     steer(RIGHT);
 170               		.stabn	68,0,19,.LM9-.LFBB1
 171               	.LM9:
 172 0040 81E0      		ldi r24,lo8(1)
 173 0042 0C94 0000 		jmp steer
 174               	.L5:
  20:source/application/LIDARBOT.c ****   }
  21:source/application/LIDARBOT.c ****   else if ((obstacle.valid == VALID) && (obstacle.proximity < 45) && (botmoving == 0)) {
 175               		.stabn	68,0,21,.LM10-.LFBB1
 176               	.LM10:
 177 0046 8091 0000 		lds r24,obstacle+2
 178 004a 8032      		cpi r24,lo8(32)
 179 004c 01F4      		brne .L6
 180               		.stabn	68,0,21,.LM11-.LFBB1
 181               	.LM11:
 182 004e 8091 0000 		lds r24,obstacle
 183 0052 9091 0000 		lds r25,obstacle+1
 184 0056 8D97      		sbiw r24,45
 185 0058 00F4      		brsh .L6
 186               		.stabn	68,0,21,.LM12-.LFBB1
 187               	.LM12:
 188 005a 8091 0000 		lds r24,botmoving
 189 005e 8823      		tst r24
 190 0060 01F0      		breq .L7
 191               	.L6:
  22:source/application/LIDARBOT.c ****     /* Data is good but obstacle is in colision distance. Steer clear. */
  23:source/application/LIDARBOT.c ****     steer(RIGHT);
  24:source/application/LIDARBOT.c ****   }
  25:source/application/LIDARBOT.c ****   else if ((obstacle.valid == VALID) && (obstacle.proximity > 45) && (botmoving == 0)){
 192               		.stabn	68,0,25,.LM13-.LFBB1
 193               	.LM13:
 194 0062 8091 0000 		lds r24,obstacle+2
 195 0066 8032      		cpi r24,lo8(32)
 196 0068 01F4      		brne .L1
 197               		.stabn	68,0,25,.LM14-.LFBB1
 198               	.LM14:
 199 006a 8091 0000 		lds r24,obstacle
 200 006e 9091 0000 		lds r25,obstacle+1
 201 0072 8E97      		sbiw r24,46
 202 0074 00F0      		brlo .L1
 203               		.stabn	68,0,25,.LM15-.LFBB1
 204               	.LM15:
 205 0076 8091 0000 		lds r24,botmoving
 206 007a 8111      		cpse r24,__zero_reg__
 207 007c 00C0      		rjmp .L1
  26:source/application/LIDARBOT.c ****     /* No obstacles ahead. Coast away.*/
  27:source/application/LIDARBOT.c ****     drive(FORWARD, COAST);
 208               		.stabn	68,0,27,.LM16-.LFBB1
 209               	.LM16:
 210 007e 40E0      		ldi r20,0
 211 0080 50E0      		ldi r21,0
 212 0082 68E4      		ldi r22,lo8(72)
 213 0084 72E4      		ldi r23,lo8(66)
 214 0086 82E0      		ldi r24,lo8(2)
 215 0088 0C94 0000 		jmp drive
 216               	.L1:
 217 008c 0895      		ret
 218               		.size	navigate, .-navigate
 219               	.Lscope1:
 220               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 221               		.stabd	78,0,0
 222               		.stabs	"initbot:F(0,49)",36,0,31,initbot
 223               	.global	initbot
 224               		.type	initbot, @function
 225               	initbot:
 226               		.stabd	46,0,0
  28:source/application/LIDARBOT.c ****   }
  29:source/application/LIDARBOT.c **** }
  30:source/application/LIDARBOT.c **** 
  31:source/application/LIDARBOT.c **** void initbot(){
 227               		.stabn	68,0,31,.LM17-.LFBB2
 228               	.LM17:
 229               	.LFBB2:
 230               	/* prologue: function */
 231               	/* frame size = 0 */
 232               	/* stack size = 0 */
 233               	.L__stack_usage = 0
  32:source/application/LIDARBOT.c ****   /* Initialize all robot functions */
  33:source/application/LIDARBOT.c ****   clocksetup();  // Master clock setup
 234               		.stabn	68,0,33,.LM18-.LFBB2
 235               	.LM18:
 236 008e 0E94 0000 		call clocksetup
  34:source/application/LIDARBOT.c ****   usartinit();   // Communication setup
 237               		.stabn	68,0,34,.LM19-.LFBB2
 238               	.LM19:
 239 0092 0E94 0000 		call usartinit
  35:source/application/LIDARBOT.c ****   lidarinit();   // LIDAR read setup
 240               		.stabn	68,0,35,.LM20-.LFBB2
 241               	.LM20:
 242 0096 0E94 0000 		call lidarinit
  36:source/application/LIDARBOT.c ****   motorinit();   // Propulsion setup
 243               		.stabn	68,0,36,.LM21-.LFBB2
 244               	.LM21:
 245 009a 0C94 0000 		jmp motorinit
 246               		.size	initbot, .-initbot
 247               	.Lscope2:
 248               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 249               		.stabd	78,0,0
 250               		.section	.text.startup,"ax",@progbits
 251               		.stabs	"main:F(0,1)",36,0,39,main
 252               	.global	main
 253               		.type	main, @function
 254               	main:
 255               		.stabd	46,0,0
  37:source/application/LIDARBOT.c **** }
  38:source/application/LIDARBOT.c **** 
  39:source/application/LIDARBOT.c **** int main(){
 256               		.stabn	68,0,39,.LM22-.LFBB3
 257               	.LM22:
 258               	.LFBB3:
 259               	/* prologue: function */
 260               	/* frame size = 0 */
 261               	/* stack size = 0 */
 262               	.L__stack_usage = 0
  40:source/application/LIDARBOT.c ****   // Initialize BOT
  41:source/application/LIDARBOT.c ****   initbot();
 263               		.stabn	68,0,41,.LM23-.LFBB3
 264               	.LM23:
 265 0000 0E94 0000 		call initbot
 266               	.LBB4:
 267               	.LBB5:
 268               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h",132,0,0,.Ltext1
 269               	.Ltext1:
   1:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    All rights reserved.
   5:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
   6:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
   9:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  12:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      the documentation and/or other materials provided with the
  15:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      distribution.
  16:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  17:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      from this software without specific prior written permission.
  20:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  21:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  33:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /* $Id$ */
  34:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  35:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  38:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #ifndef __DOXYGEN__
  39:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #  endif
  42:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  44:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #include <inttypes.h>
  45:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #include <util/delay_basic.h>
  46:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #include <math.h>
  47:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  48:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /** \file */
  49:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \code
  51:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     #include <util/delay.h>
  54:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \endcode
  55:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  56:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     used.
  60:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  61:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     convenience functions where actual time values can be specified
  64:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  70:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     routines linked into the application.
  78:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  79:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  83:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** */
  84:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  85:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
  89:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  90:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #ifndef F_CPU
  91:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /** \ingroup util_delay
  94:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \def F_CPU
  95:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \brief CPU frequency in Hz
  96:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  97:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 103:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     integer value.
 107:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****  */
 108:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** # define F_CPU 1000000UL
 109:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
 110:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 111:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #ifndef __OPTIMIZE__
 112:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
 114:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 115:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   __STDC_HOSTED__
 118:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #  include <math.h>
 119:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
 120:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 121:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /**
 122:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \ingroup util_delay
 123:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 124:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 126:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 129:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 131:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    user will not be informed about decreased resolution.
 136:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 137:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    no delay i.e., 0ms.
 141:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 142:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    microseconds of delay.
 146:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 147:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    respectively.
 151:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 152:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \note
 153:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 154:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    The implementation of _delay_ms() based on
 155:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    must be defined before including this header file. Also, the
 159:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    not available to the compiler then.
 163:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 164:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****  */
 165:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** void
 166:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** _delay_ms(double __ms)
 167:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** {
 168:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	double __tmp ;
 169:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   __STDC_HOSTED__
 172:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	uint32_t __ticks_dc;
 173:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 176:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 179:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 182:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#else
 183:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		//round up by default
 184:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#endif
 186:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 187:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 270               		.stabn	68,0,187,.LM24-.LFBB3
 271               	.LM24:
 272 0004 2FEF      		ldi r18,lo8(1599999)
 273 0006 89E6      		ldi r24,hi8(1599999)
 274 0008 98E1      		ldi r25,hlo8(1599999)
 275 000a 2150      	1:	subi r18,1
 276 000c 8040      		sbci r24,0
 277 000e 9040      		sbci r25,0
 278 0010 01F4      		brne 1b
 279 0012 00C0      		rjmp .
 280 0014 0000      		nop
 281               	.LBE5:
 282               	.LBE4:
 283               		.stabs	"source/application/LIDARBOT.c",132,0,0,.Ltext2
 284               	.Ltext2:
  42:source/application/LIDARBOT.c ****   // A small delay to give the bot owner time to step away
  43:source/application/LIDARBOT.c ****   _delay_ms(2000);
  44:source/application/LIDARBOT.c **** 
  45:source/application/LIDARBOT.c ****   // Enable global interrupts - Bot Key ON
  46:source/application/LIDARBOT.c ****   sei();
 285               		.stabn	68,0,46,.LM25-.LFBB3
 286               	.LM25:
 287               	/* #APP */
 288               	 ;  46 "source/application/LIDARBOT.c" 1
 289 0016 7894      		sei
 290               	 ;  0 "" 2
 291               	/* #NOAPP */
 292               	.L18:
 293 0018 00C0      		rjmp .L18
 294               		.size	main, .-main
 295               	.Lscope3:
 296               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 297               		.stabd	78,0,0
 298               		.text
 299               		.stabs	"__vector_18:F(0,49)",36,0,57,__vector_18
 300               	.global	__vector_18
 301               		.type	__vector_18, @function
 302               	__vector_18:
 303               		.stabd	46,0,0
  47:source/application/LIDARBOT.c **** 
  48:source/application/LIDARBOT.c ****   while (1) {
  49:source/application/LIDARBOT.c ****     /* Keep Running */
  50:source/application/LIDARBOT.c ****   }
  51:source/application/LIDARBOT.c **** }
  52:source/application/LIDARBOT.c **** 
  53:source/application/LIDARBOT.c **** /******************************************************************************/
  54:source/application/LIDARBOT.c **** /*                     INTERRUPT SERVICE ROUTINES                             */
  55:source/application/LIDARBOT.c **** /******************************************************************************/
  56:source/application/LIDARBOT.c **** /* USART RECEIVE TASK */
  57:source/application/LIDARBOT.c **** ISR(USART_RX_vect){ /* Asynchronous Hardware Interrupt */
 304               		.stabn	68,0,57,.LM26-.LFBB4
 305               	.LM26:
 306               	.LFBB4:
 307 009e 1F92      		push r1
 308 00a0 0F92      		push r0
 309 00a2 0FB6      		in r0,__SREG__
 310 00a4 0F92      		push r0
 311 00a6 1124      		clr __zero_reg__
 312 00a8 2F93      		push r18
 313 00aa 3F93      		push r19
 314 00ac 4F93      		push r20
 315 00ae 5F93      		push r21
 316 00b0 6F93      		push r22
 317 00b2 7F93      		push r23
 318 00b4 8F93      		push r24
 319 00b6 9F93      		push r25
 320 00b8 AF93      		push r26
 321 00ba BF93      		push r27
 322 00bc EF93      		push r30
 323 00be FF93      		push r31
 324               	/* prologue: Signal */
 325               	/* frame size = 0 */
 326               	/* stack size = 15 */
 327               	.L__stack_usage = 15
  58:source/application/LIDARBOT.c ****   /* We want our interrupt service routine to be quick as possible. Which is why
  59:source/application/LIDARBOT.c ****    * all this routine will do is write to the ring buffer and get out. However,
  60:source/application/LIDARBOT.c ****    * we need our cpu to be quicker so that elements from that buffer are emptied
  61:source/application/LIDARBOT.c ****    * faster than this ISR can populate the buffer. This was one of the prime
  62:source/application/LIDARBOT.c ****    * reasons why the chosen clock was 4 Mhz.
  63:source/application/LIDARBOT.c ****    */
  64:source/application/LIDARBOT.c ****   if((rxBufferWrite() != BUFFER_OK)){
 328               		.stabn	68,0,64,.LM27-.LFBB4
 329               	.LM27:
 330 00c0 0E94 0000 		call rxBufferWrite
 331 00c4 892B      		or r24,r25
 332 00c6 01F0      		breq .L19
  65:source/application/LIDARBOT.c ****     readLIDAR();
 333               		.stabn	68,0,65,.LM28-.LFBB4
 334               	.LM28:
 335 00c8 0E94 0000 		call readLIDAR
  66:source/application/LIDARBOT.c ****     rxBufferWrite();
 336               		.stabn	68,0,66,.LM29-.LFBB4
 337               	.LM29:
 338 00cc 0E94 0000 		call rxBufferWrite
 339               	.L19:
 340               	/* epilogue start */
  67:source/application/LIDARBOT.c ****   }
  68:source/application/LIDARBOT.c **** }
 341               		.stabn	68,0,68,.LM30-.LFBB4
 342               	.LM30:
 343 00d0 FF91      		pop r31
 344 00d2 EF91      		pop r30
 345 00d4 BF91      		pop r27
 346 00d6 AF91      		pop r26
 347 00d8 9F91      		pop r25
 348 00da 8F91      		pop r24
 349 00dc 7F91      		pop r23
 350 00de 6F91      		pop r22
 351 00e0 5F91      		pop r21
 352 00e2 4F91      		pop r20
 353 00e4 3F91      		pop r19
 354 00e6 2F91      		pop r18
 355 00e8 0F90      		pop r0
 356 00ea 0FBE      		out __SREG__,r0
 357 00ec 0F90      		pop r0
 358 00ee 1F90      		pop r1
 359 00f0 1895      		reti
 360               		.size	__vector_18, .-__vector_18
 361               	.Lscope4:
 362               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 363               		.stabd	78,0,0
 364               		.stabs	"__vector_14:F(0,49)",36,0,71,__vector_14
 365               	.global	__vector_14
 366               		.type	__vector_14, @function
 367               	__vector_14:
 368               		.stabd	46,0,0
  69:source/application/LIDARBOT.c **** 
  70:source/application/LIDARBOT.c **** /* USART BUFFER PROCESSING TASK */
  71:source/application/LIDARBOT.c **** ISR(TIMER0_COMPA_vect){ /* 320 us SOFTWARE INTERRUPT TASK RATE */
 369               		.stabn	68,0,71,.LM31-.LFBB5
 370               	.LM31:
 371               	.LFBB5:
 372 00f2 1F92      		push r1
 373 00f4 0F92      		push r0
 374 00f6 0FB6      		in r0,__SREG__
 375 00f8 0F92      		push r0
 376 00fa 1124      		clr __zero_reg__
 377 00fc 2F93      		push r18
 378 00fe 3F93      		push r19
 379 0100 4F93      		push r20
 380 0102 5F93      		push r21
 381 0104 6F93      		push r22
 382 0106 7F93      		push r23
 383 0108 8F93      		push r24
 384 010a 9F93      		push r25
 385 010c AF93      		push r26
 386 010e BF93      		push r27
 387 0110 EF93      		push r30
 388 0112 FF93      		push r31
 389               	/* prologue: Signal */
 390               	/* frame size = 0 */
 391               	/* stack size = 15 */
 392               	.L__stack_usage = 15
  72:source/application/LIDARBOT.c ****   /* Here we wait until there are atleast 50 bytes or close to 3 frames are in
  73:source/application/LIDARBOT.c ****    * the buffer to start reading. This method helps not reading the buffer
  74:source/application/LIDARBOT.c ****    * when there is no data and also keeps the interrupt time short.
  75:source/application/LIDARBOT.c ****    */
  76:source/application/LIDARBOT.c ****   if (buffercount>50) {
 393               		.stabn	68,0,76,.LM32-.LFBB5
 394               	.LM32:
 395 0114 8091 0000 		lds r24,buffercount
 396 0118 9091 0000 		lds r25,buffercount+1
 397 011c C397      		sbiw r24,51
 398 011e 00F0      		brlo .L24
  77:source/application/LIDARBOT.c ****     readLIDAR();
 399               		.stabn	68,0,77,.LM33-.LFBB5
 400               	.LM33:
 401 0120 0E94 0000 		call readLIDAR
 402               	.L24:
 403               	/* epilogue start */
  78:source/application/LIDARBOT.c ****   }
  79:source/application/LIDARBOT.c **** }
 404               		.stabn	68,0,79,.LM34-.LFBB5
 405               	.LM34:
 406 0124 FF91      		pop r31
 407 0126 EF91      		pop r30
 408 0128 BF91      		pop r27
 409 012a AF91      		pop r26
 410 012c 9F91      		pop r25
 411 012e 8F91      		pop r24
 412 0130 7F91      		pop r23
 413 0132 6F91      		pop r22
 414 0134 5F91      		pop r21
 415 0136 4F91      		pop r20
 416 0138 3F91      		pop r19
 417 013a 2F91      		pop r18
 418 013c 0F90      		pop r0
 419 013e 0FBE      		out __SREG__,r0
 420 0140 0F90      		pop r0
 421 0142 1F90      		pop r1
 422 0144 1895      		reti
 423               		.size	__vector_14, .-__vector_14
 424               	.Lscope5:
 425               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 426               		.stabd	78,0,0
 427               		.stabs	"__vector_11:F(0,49)",36,0,82,__vector_11
 428               	.global	__vector_11
 429               		.type	__vector_11, @function
 430               	__vector_11:
 431               		.stabd	46,0,0
  80:source/application/LIDARBOT.c **** 
  81:source/application/LIDARBOT.c **** /* PROPULSION/NAVIGATION TASK */
  82:source/application/LIDARBOT.c **** ISR(TIMER1_COMPA_vect){ /* ~ 500 ms SOFTWARE INTERRUPT TASK RATE */
 432               		.stabn	68,0,82,.LM35-.LFBB6
 433               	.LM35:
 434               	.LFBB6:
 435 0146 1F92      		push r1
 436 0148 0F92      		push r0
 437 014a 0FB6      		in r0,__SREG__
 438 014c 0F92      		push r0
 439 014e 1124      		clr __zero_reg__
 440 0150 2F93      		push r18
 441 0152 3F93      		push r19
 442 0154 4F93      		push r20
 443 0156 5F93      		push r21
 444 0158 6F93      		push r22
 445 015a 7F93      		push r23
 446 015c 8F93      		push r24
 447 015e 9F93      		push r25
 448 0160 AF93      		push r26
 449 0162 BF93      		push r27
 450 0164 EF93      		push r30
 451 0166 FF93      		push r31
 452               	/* prologue: Signal */
 453               	/* frame size = 0 */
 454               	/* stack size = 15 */
 455               	.L__stack_usage = 15
  83:source/application/LIDARBOT.c ****   /* We will have this ISR drive and steer for us. */
  84:source/application/LIDARBOT.c ****   navigate();
 456               		.stabn	68,0,84,.LM36-.LFBB6
 457               	.LM36:
 458 0168 0E94 0000 		call navigate
 459               	/* epilogue start */
  85:source/application/LIDARBOT.c **** }
 460               		.stabn	68,0,85,.LM37-.LFBB6
 461               	.LM37:
 462 016c FF91      		pop r31
 463 016e EF91      		pop r30
 464 0170 BF91      		pop r27
 465 0172 AF91      		pop r26
 466 0174 9F91      		pop r25
 467 0176 8F91      		pop r24
 468 0178 7F91      		pop r23
 469 017a 6F91      		pop r22
 470 017c 5F91      		pop r21
 471 017e 4F91      		pop r20
 472 0180 3F91      		pop r19
 473 0182 2F91      		pop r18
 474 0184 0F90      		pop r0
 475 0186 0FBE      		out __SREG__,r0
 476 0188 0F90      		pop r0
 477 018a 1F90      		pop r1
 478 018c 1895      		reti
 479               		.size	__vector_11, .-__vector_11
 480               	.Lscope6:
 481               		.stabs	"",36,0,0,.Lscope6-.LFBB6
 482               		.stabd	78,0,0
 483               		.comm	botmoving,1,1
 484               		.comm	buffercount,2,1
 485               		.comm	rxBuffer,1026,1
 486               		.comm	obstacle,3,1
 487               		.comm	tfmini,9,1
 488               		.stabs	"tfmini:G(0,50)=B(8,2)",32,0,28,0
 489               		.stabs	"obstacle:G(0,51)=B(8,4)",32,0,36,0
 490               		.stabs	"rxBuffer:G(0,52)=B(7,5)",32,0,37,0
 491               		.stabs	"buffercount:G(0,53)=B(0,4)",32,0,38,0
 492               		.stabs	"botmoving:G(0,13)",32,0,27,0
 493               		.stabs	"",100,0,0,.Letext0
 494               	.Letext0:
 495               		.ident	"GCC: (GNU) 5.4.0"
 496               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 LIDARBOT.c
     /tmp/cc5bskjN.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc5bskjN.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc5bskjN.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc5bskjN.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc5bskjN.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc5bskjN.s:118    .text:0000000000000000 navigate
                            *COM*:0000000000000003 obstacle
                            *COM*:0000000000000001 botmoving
     /tmp/cc5bskjN.s:225    .text:000000000000008e initbot
     /tmp/cc5bskjN.s:254    .text.startup:0000000000000000 main
     /tmp/cc5bskjN.s:302    .text:000000000000009e __vector_18
     /tmp/cc5bskjN.s:367    .text:00000000000000f2 __vector_14
                            *COM*:0000000000000002 buffercount
     /tmp/cc5bskjN.s:430    .text:0000000000000146 __vector_11
                            *COM*:0000000000000402 rxBuffer
                            *COM*:0000000000000009 tfmini

UNDEFINED SYMBOLS
stop
steer
drive
clocksetup
usartinit
lidarinit
motorinit
rxBufferWrite
readLIDAR
__do_clear_bss

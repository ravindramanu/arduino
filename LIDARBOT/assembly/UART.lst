   1               		.file	"UART.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/manu/github/arduino/LIDARBOT/",100,0,2,.Ltext0
   8               		.stabs	"source/os_rios/UART.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=r(0,2);0;127;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"__int128:t(0,6)=@s128;r(0,6);02000000000000000000000000000000000000000000;0177777777777777
  18               		.stabs	"__int128 unsigned:t(0,7)=@s128;r(0,7);0;03777777777777777777777777777777777777777777;",128
  19               		.stabs	"long long int:t(0,8)=@s64;r(0,8);01000000000000000000000;00777777777777777777777;",128,0,0
  20               		.stabs	"long long unsigned int:t(0,9)=@s64;r(0,9);0;01777777777777777777777;",128,0,0,0
  21               		.stabs	"short int:t(0,10)=r(0,10);-32768;32767;",128,0,0,0
  22               		.stabs	"short unsigned int:t(0,11)=r(0,11);0;0177777;",128,0,0,0
  23               		.stabs	"signed char:t(0,12)=@s8;r(0,12);-128;127;",128,0,0,0
  24               		.stabs	"unsigned char:t(0,13)=@s8;r(0,13);0;255;",128,0,0,0
  25               		.stabs	"float:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"double:t(0,15)=r(0,1);4;0;",128,0,0,0
  27               		.stabs	"long double:t(0,16)=r(0,1);4;0;",128,0,0,0
  28               		.stabs	"short _Fract:t(0,17)=r(0,1);1;0;",128,0,0,0
  29               		.stabs	"_Fract:t(0,18)=r(0,1);2;0;",128,0,0,0
  30               		.stabs	"long _Fract:t(0,19)=r(0,1);4;0;",128,0,0,0
  31               		.stabs	"long long _Fract:t(0,20)=r(0,1);8;0;",128,0,0,0
  32               		.stabs	"unsigned short _Fract:t(0,21)=r(0,1);1;0;",128,0,0,0
  33               		.stabs	"unsigned _Fract:t(0,22)=r(0,1);2;0;",128,0,0,0
  34               		.stabs	"unsigned long _Fract:t(0,23)=r(0,1);4;0;",128,0,0,0
  35               		.stabs	"unsigned long long _Fract:t(0,24)=r(0,1);8;0;",128,0,0,0
  36               		.stabs	"_Sat short _Fract:t(0,25)=r(0,1);1;0;",128,0,0,0
  37               		.stabs	"_Sat _Fract:t(0,26)=r(0,1);2;0;",128,0,0,0
  38               		.stabs	"_Sat long _Fract:t(0,27)=r(0,1);4;0;",128,0,0,0
  39               		.stabs	"_Sat long long _Fract:t(0,28)=r(0,1);8;0;",128,0,0,0
  40               		.stabs	"_Sat unsigned short _Fract:t(0,29)=r(0,1);1;0;",128,0,0,0
  41               		.stabs	"_Sat unsigned _Fract:t(0,30)=r(0,1);2;0;",128,0,0,0
  42               		.stabs	"_Sat unsigned long _Fract:t(0,31)=r(0,1);4;0;",128,0,0,0
  43               		.stabs	"_Sat unsigned long long _Fract:t(0,32)=r(0,1);8;0;",128,0,0,0
  44               		.stabs	"short _Accum:t(0,33)=r(0,1);2;0;",128,0,0,0
  45               		.stabs	"_Accum:t(0,34)=r(0,1);4;0;",128,0,0,0
  46               		.stabs	"long _Accum:t(0,35)=r(0,1);8;0;",128,0,0,0
  47               		.stabs	"long long _Accum:t(0,36)=r(0,1);8;0;",128,0,0,0
  48               		.stabs	"unsigned short _Accum:t(0,37)=r(0,1);2;0;",128,0,0,0
  49               		.stabs	"unsigned _Accum:t(0,38)=r(0,1);4;0;",128,0,0,0
  50               		.stabs	"unsigned long _Accum:t(0,39)=r(0,1);8;0;",128,0,0,0
  51               		.stabs	"unsigned long long _Accum:t(0,40)=r(0,1);8;0;",128,0,0,0
  52               		.stabs	"_Sat short _Accum:t(0,41)=r(0,1);2;0;",128,0,0,0
  53               		.stabs	"_Sat _Accum:t(0,42)=r(0,1);4;0;",128,0,0,0
  54               		.stabs	"_Sat long _Accum:t(0,43)=r(0,1);8;0;",128,0,0,0
  55               		.stabs	"_Sat long long _Accum:t(0,44)=r(0,1);8;0;",128,0,0,0
  56               		.stabs	"_Sat unsigned short _Accum:t(0,45)=r(0,1);2;0;",128,0,0,0
  57               		.stabs	"_Sat unsigned _Accum:t(0,46)=r(0,1);4;0;",128,0,0,0
  58               		.stabs	"_Sat unsigned long _Accum:t(0,47)=r(0,1);8;0;",128,0,0,0
  59               		.stabs	"_Sat unsigned long long _Accum:t(0,48)=r(0,1);8;0;",128,0,0,0
  60               		.stabs	"void:t(0,49)=(0,49)",128,0,0,0
  61               		.stabs	"source/os_rios/UART.h",130,0,0,0
  62               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/avr/io.h",130,0,0,0
  63               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/avr/sfr_defs.h",130,0,0,0
  64               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/inttypes.h",130,0,0,0
  65               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/stdint.h",130,0,0,0
  66               		.stabs	"int8_t:t(5,1)=(0,12)",128,0,125,0
  67               		.stabs	"uint8_t:t(5,2)=(0,13)",128,0,126,0
  68               		.stabs	"int16_t:t(5,3)=(0,1)",128,0,127,0
  69               		.stabs	"uint16_t:t(5,4)=(0,4)",128,0,128,0
  70               		.stabs	"int32_t:t(5,5)=(0,3)",128,0,129,0
  71               		.stabs	"uint32_t:t(5,6)=(0,5)",128,0,130,0
  72               		.stabs	"int64_t:t(5,7)=(0,8)",128,0,132,0
  73               		.stabs	"uint64_t:t(5,8)=(0,9)",128,0,133,0
  74               		.stabs	"intptr_t:t(5,9)=(5,3)",128,0,146,0
  75               		.stabs	"uintptr_t:t(5,10)=(5,4)",128,0,151,0
  76               		.stabs	"int_least8_t:t(5,11)=(5,1)",128,0,163,0
  77               		.stabs	"uint_least8_t:t(5,12)=(5,2)",128,0,168,0
  78               		.stabs	"int_least16_t:t(5,13)=(5,3)",128,0,173,0
  79               		.stabs	"uint_least16_t:t(5,14)=(5,4)",128,0,178,0
  80               		.stabs	"int_least32_t:t(5,15)=(5,5)",128,0,183,0
  81               		.stabs	"uint_least32_t:t(5,16)=(5,6)",128,0,188,0
  82               		.stabs	"int_least64_t:t(5,17)=(5,7)",128,0,196,0
  83               		.stabs	"uint_least64_t:t(5,18)=(5,8)",128,0,203,0
  84               		.stabs	"int_fast8_t:t(5,19)=(5,1)",128,0,217,0
  85               		.stabs	"uint_fast8_t:t(5,20)=(5,2)",128,0,222,0
  86               		.stabs	"int_fast16_t:t(5,21)=(5,3)",128,0,227,0
  87               		.stabs	"uint_fast16_t:t(5,22)=(5,4)",128,0,232,0
  88               		.stabs	"int_fast32_t:t(5,23)=(5,5)",128,0,237,0
  89               		.stabs	"uint_fast32_t:t(5,24)=(5,6)",128,0,242,0
  90               		.stabs	"int_fast64_t:t(5,25)=(5,7)",128,0,250,0
  91               		.stabs	"uint_fast64_t:t(5,26)=(5,8)",128,0,257,0
  92               		.stabs	"intmax_t:t(5,27)=(5,7)",128,0,277,0
  93               		.stabs	"uintmax_t:t(5,28)=(5,8)",128,0,282,0
  94               		.stabn	162,0,0,0
  95               		.stabs	"int_farptr_t:t(4,1)=(5,5)",128,0,77,0
  96               		.stabs	"uint_farptr_t:t(4,2)=(5,6)",128,0,81,0
  97               		.stabn	162,0,0,0
  98               		.stabn	162,0,0,0
  99               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/avr/fuse.h",130,0,0,0
 100               		.stabs	"__fuse_t:t(6,1)=(6,2)=s3low:(0,13),0,8;high:(0,13),8,8;extended:(0,13),16,8;;",128,0,244,0
 101               		.stabn	162,0,0,0
 102               		.stabn	162,0,0,0
 103               		.stabs	"source/os_rios/../drivers/LIDAR_driver.h",130,0,0,0
 104               		.stabs	"LIDARMODULESTRUCT:T(7,1)=s9headbyte1:(0,13),0,8;headbyte2:(0,13),8,8;distanceLow:(0,13),16
 105               		.stabs	"LIDAR:t(7,2)=(7,1)",128,0,55,0
 106               		.stabs	"OBJECTPROXIMITYSTRUCT:T(7,3)=s3proximity:(0,4),0,16;valid:(0,13),16,8;;",128,0,0,0
 107               		.stabs	"OBJECT:t(7,4)=(7,3)",128,0,64,0
 108               		.stabn	162,0,0,0
 109               		.stabs	"bufferStatus:T(1,1)=eBUFFER_OK:0,BUFFER_EMPTY:1,BUFFER_FULL:2,;",128,0,0,0
 110               		.stabs	"Buffer:T(1,2)=s1026data:(1,3)=ar(1,4)=r(1,4);0;0177777;;0;1023;(0,13),0,8192;readindex:(0,
 111               		.stabs	"Buffer:t(1,5)=(1,2)",128,0,34,0
 112               		.stabn	162,0,0,0
 113               		.stabs	"usartinit:F(0,49)",36,0,3,usartinit
 114               	.global	usartinit
 115               		.type	usartinit, @function
 116               	usartinit:
 117               		.stabd	46,0,0
   1:source/os_rios/UART.c **** #include "UART.h"
   2:source/os_rios/UART.c **** 
   3:source/os_rios/UART.c **** void usartinit(void){
 118               		.stabn	68,0,3,.LM0-.LFBB1
 119               	.LM0:
 120               	.LFBB1:
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
   4:source/os_rios/UART.c ****   // Initialize the hardware and software USART
   5:source/os_rios/UART.c ****   hardwareserialsetup();
 125               		.stabn	68,0,5,.LM1-.LFBB1
 126               	.LM1:
 127 0000 0E94 0000 		call hardwareserialsetup
   6:source/os_rios/UART.c ****   softwareserialsetup();
 128               		.stabn	68,0,6,.LM2-.LFBB1
 129               	.LM2:
 130 0004 0C94 0000 		jmp softwareserialsetup
 131               		.size	usartinit, .-usartinit
 132               	.Lscope1:
 133               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 134               		.stabd	78,0,0
 135               		.stabs	"softwareserialTransmit:F(0,49)",36,0,9,softwareserialTransmit
 136               		.stabs	"byte:P(0,13)",64,0,9,24
 137               	.global	softwareserialTransmit
 138               		.type	softwareserialTransmit, @function
 139               	softwareserialTransmit:
 140               		.stabd	46,0,0
   7:source/os_rios/UART.c **** }
   8:source/os_rios/UART.c **** 
   9:source/os_rios/UART.c **** void softwareserialTransmit(unsigned char byte){
 141               		.stabn	68,0,9,.LM3-.LFBB2
 142               	.LM3:
 143               	.LFBB2:
 144               	/* prologue: function */
 145               	/* frame size = 0 */
 146               	/* stack size = 0 */
 147               	.L__stack_usage = 0
  10:source/os_rios/UART.c ****   /* The software serial transmit function is for debug only.
  11:source/os_rios/UART.c ****    * This function will send out any data that is passed into it on to a
  12:source/os_rios/UART.c ****    * software emulated UART on pin 12 of the Arduino.
  13:source/os_rios/UART.c ****    */
  14:source/os_rios/UART.c ****   unsigned char bitmask=0x01;
  15:source/os_rios/UART.c **** 
  16:source/os_rios/UART.c ****   // Send out start bit by turning PORTB4 OFF and wait ~104 ms (since baud is 9600)
  17:source/os_rios/UART.c ****   PORTB &= ~(1<<PORTB4);
 148               		.stabn	68,0,17,.LM4-.LFBB2
 149               	.LM4:
 150 0008 2C98      		cbi 0x5,4
 151               	.LBB10:
 152               	.LBB11:
 153               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h",132,0,0,.Ltext1
 154               	.Ltext1:
   1:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    All rights reserved.
   5:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
   6:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
   9:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  12:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      the documentation and/or other materials provided with the
  15:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      distribution.
  16:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  17:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****      from this software without specific prior written permission.
  20:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  21:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  33:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /* $Id$ */
  34:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  35:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  38:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #ifndef __DOXYGEN__
  39:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #  endif
  42:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  44:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #include <inttypes.h>
  45:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #include <util/delay_basic.h>
  46:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #include <math.h>
  47:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  48:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /** \file */
  49:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \code
  51:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     #include <util/delay.h>
  54:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \endcode
  55:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  56:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     used.
  60:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  61:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     convenience functions where actual time values can be specified
  64:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  70:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     routines linked into the application.
  78:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  79:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  83:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** */
  84:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  85:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
  89:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  90:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #ifndef F_CPU
  91:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /** \ingroup util_delay
  94:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \def F_CPU
  95:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     \brief CPU frequency in Hz
  96:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
  97:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 103:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****     integer value.
 107:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****  */
 108:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** # define F_CPU 1000000UL
 109:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
 110:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 111:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #ifndef __OPTIMIZE__
 112:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
 114:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 115:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   __STDC_HOSTED__
 118:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #  include <math.h>
 119:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
 120:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 121:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /**
 122:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \ingroup util_delay
 123:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 124:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 126:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 129:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 131:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    user will not be informed about decreased resolution.
 136:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 137:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    no delay i.e., 0ms.
 141:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 142:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    microseconds of delay.
 146:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 147:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    respectively.
 151:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 152:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \note
 153:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 154:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    The implementation of _delay_ms() based on
 155:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    must be defined before including this header file. Also, the
 159:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    not available to the compiler then.
 163:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 164:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****  */
 165:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** void
 166:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** _delay_ms(double __ms)
 167:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** {
 168:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	double __tmp ;
 169:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   __STDC_HOSTED__
 172:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	uint32_t __ticks_dc;
 173:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 176:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 179:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 182:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#else
 183:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		//round up by default
 184:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#endif
 186:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 187:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 189:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #else
 190:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	uint16_t __ticks;
 191:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	if (__tmp < 1.0)
 193:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks = 1;
 194:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	else if (__tmp > 65535)
 195:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	{
 196:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		while(__ticks)
 199:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		{
 200:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 			// wait 1/10 ms
 201:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 			__ticks --;
 203:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		}
 204:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		return;
 205:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	}
 206:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	else
 207:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #endif
 210:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** }
 211:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 212:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** /**
 213:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \ingroup util_delay
 214:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 215:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 217:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 220:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 222:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    will not be informed about this case.
 225:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 226:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    no delay i.e., 0us.
 230:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 231:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    microseconds of delay.
 235:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 236:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    respectively.
 240:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 241:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \note
 242:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 243:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    The implementation of _delay_ms() based on
 244:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    must be defined before including this header file. Also, the
 248:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****    not available to the compiler then.
 252:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 253:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****  */
 254:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** void
 255:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** _delay_us(double __us)
 256:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** {
 257:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	double __tmp ;
 258:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h ****   __STDC_HOSTED__
 261:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	uint32_t __ticks_dc;
 262:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 265:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 268:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 271:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#else
 272:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		//round up by default
 273:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	#endif
 275:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 
 276:/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 155               		.stabn	68,0,276,.LM5-.LFBB2
 156               	.LM5:
 157 000a 4AE8      		ldi r20,lo8(-118)
 158 000c 4A95      	1:	dec r20
 159 000e 01F4      		brne 1b
 160 0010 00C0      		rjmp .
 161 0012 28E0      		ldi r18,lo8(8)
 162 0014 30E0      		ldi r19,0
 163               	.LBE11:
 164               	.LBE10:
 165               		.stabs	"source/os_rios/UART.c",132,0,0,.Ltext2
 166               	.Ltext2:
  14:source/os_rios/UART.c **** 
 167               		.stabn	68,0,14,.LM6-.LFBB2
 168               	.LM6:
 169 0016 91E0      		ldi r25,lo8(1)
 170               	.L5:
  18:source/os_rios/UART.c ****   _delay_us(EMULATED_UARTDELAY_MICROSEC);
  19:source/os_rios/UART.c **** 
  20:source/os_rios/UART.c ****   // Toggle PORTB4 according to data bits in the reverse order LSB --> MSB
  21:source/os_rios/UART.c ****   while (bitmask) {
  22:source/os_rios/UART.c ****     if (byte & bitmask) {
 171               		.stabn	68,0,22,.LM7-.LFBB2
 172               	.LM7:
 173 0018 482F      		mov r20,r24
 174 001a 4923      		and r20,r25
 175 001c 01F0      		breq .L3
  23:source/os_rios/UART.c ****       PORTB |= (1<<PORTB4);
 176               		.stabn	68,0,23,.LM8-.LFBB2
 177               	.LM8:
 178 001e 2C9A      		sbi 0x5,4
 179 0020 00C0      		rjmp .L7
 180               	.L3:
  24:source/os_rios/UART.c ****       _delay_us(EMULATED_UARTDELAY_MICROSEC);
  25:source/os_rios/UART.c ****     }
  26:source/os_rios/UART.c ****     else {
  27:source/os_rios/UART.c ****       PORTB &= ~(1<<PORTB4);
 181               		.stabn	68,0,27,.LM9-.LFBB2
 182               	.LM9:
 183 0022 2C98      		cbi 0x5,4
 184               	.L7:
 185               	.LBB12:
 186               	.LBB13:
 187               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h",132,0,0,.Ltext3
 188               	.Ltext3:
 189               		.stabn	68,0,276,.LM10-.LFBB2
 190               	.LM10:
 191 0024 4AE8      		ldi r20,lo8(-118)
 192 0026 4A95      	1:	dec r20
 193 0028 01F4      		brne 1b
 194 002a 00C0      		rjmp .
 195               	.LBE13:
 196               	.LBE12:
 197               		.stabs	"source/os_rios/UART.c",132,0,0,.Ltext4
 198               	.Ltext4:
  28:source/os_rios/UART.c ****       _delay_us(EMULATED_UARTDELAY_MICROSEC);
  29:source/os_rios/UART.c ****     }
  30:source/os_rios/UART.c ****     bitmask=bitmask<<1;
 199               		.stabn	68,0,30,.LM11-.LFBB2
 200               	.LM11:
 201 002c 990F      		lsl r25
 202 002e 2150      		subi r18,1
 203 0030 3109      		sbc r19,__zero_reg__
  21:source/os_rios/UART.c ****     if (byte & bitmask) {
 204               		.stabn	68,0,21,.LM12-.LFBB2
 205               	.LM12:
 206 0032 01F4      		brne .L5
  31:source/os_rios/UART.c ****   }
  32:source/os_rios/UART.c **** 
  33:source/os_rios/UART.c ****   // Send out stop bit by turning PORTB4 ON and wait ~104 ms (since baud is 9600).
  34:source/os_rios/UART.c ****   // The line can stay ON since that would be IDLE.
  35:source/os_rios/UART.c ****   PORTB |= (1<<PORTB4);
 207               		.stabn	68,0,35,.LM13-.LFBB2
 208               	.LM13:
 209 0034 2C9A      		sbi 0x5,4
 210               	.LBB14:
 211               	.LBB15:
 212               		.stabs	"/home/manu/github/arduino/LIDARBOT/libraries/util/delay.h",132,0,0,.Ltext5
 213               	.Ltext5:
 214               		.stabn	68,0,276,.LM14-.LFBB2
 215               	.LM14:
 216 0036 8AE8      		ldi r24,lo8(-118)
 217 0038 8A95      	1:	dec r24
 218 003a 01F4      		brne 1b
 219 003c 00C0      		rjmp .
 220 003e 0895      		ret
 221               	.LBE15:
 222               	.LBE14:
 223               		.size	softwareserialTransmit, .-softwareserialTransmit
 224               		.stabs	"bitmask:r(0,13)",64,0,14,25
 225               		.stabn	192,0,0,.LFBB2-.LFBB2
 226               		.stabn	224,0,0,.Lscope2-.LFBB2
 227               	.Lscope2:
 228               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 229               		.stabd	78,0,0
 230               		.stabs	"rxBufferRead:F(1,1)",36,0,39,rxBufferRead
 231               		.stabs	"byte:P(0,50)=*(0,13)",64,0,39,24
 232               	.global	rxBufferRead
 233               		.type	rxBufferRead, @function
 234               	rxBufferRead:
 235               		.stabd	46,0,0
 236               		.stabs	"source/os_rios/UART.c",132,0,0,.Ltext6
 237               	.Ltext6:
  36:source/os_rios/UART.c ****   _delay_us(EMULATED_UARTDELAY_MICROSEC);
  37:source/os_rios/UART.c **** }
  38:source/os_rios/UART.c **** 
  39:source/os_rios/UART.c **** enum bufferStatus rxBufferRead(unsigned char * byte){
 238               		.stabn	68,0,39,.LM15-.LFBB3
 239               	.LM15:
 240               	.LFBB3:
 241               	/* prologue: function */
 242               	/* frame size = 0 */
 243               	/* stack size = 0 */
 244               	.L__stack_usage = 0
  40:source/os_rios/UART.c ****   // Check first before reading the buffer
  41:source/os_rios/UART.c ****   if ((rxBuffer.readindex) == (rxBuffer.writeindex)) {
 245               		.stabn	68,0,41,.LM16-.LFBB3
 246               	.LM16:
 247 0040 3091 0000 		lds r19,rxBuffer+1024
 248 0044 2091 0000 		lds r18,rxBuffer+1025
 249 0048 3213      		cpse r19,r18
 250 004a 00C0      		rjmp .L10
  42:source/os_rios/UART.c ****     /* This would mean the buffer is empty. */
  43:source/os_rios/UART.c ****     softwareserialTransmit(0xAA);
 251               		.stabn	68,0,43,.LM17-.LFBB3
 252               	.LM17:
 253 004c 8AEA      		ldi r24,lo8(-86)
 254 004e 0E94 0000 		call softwareserialTransmit
  44:source/os_rios/UART.c ****     return BUFFER_EMPTY;
 255               		.stabn	68,0,44,.LM18-.LFBB3
 256               	.LM18:
 257 0052 81E0      		ldi r24,lo8(1)
 258 0054 90E0      		ldi r25,0
 259 0056 0895      		ret
 260               	.L10:
  45:source/os_rios/UART.c ****   }
  46:source/os_rios/UART.c ****   // Read the variable from buffer
  47:source/os_rios/UART.c ****   *byte=rxBuffer.data[rxBuffer.readindex];
 261               		.stabn	68,0,47,.LM19-.LFBB3
 262               	.LM19:
 263 0058 E091 0000 		lds r30,rxBuffer+1024
 264 005c F0E0      		ldi r31,0
 265 005e E050      		subi r30,lo8(-(rxBuffer))
 266 0060 F040      		sbci r31,hi8(-(rxBuffer))
 267 0062 2081      		ld r18,Z
 268 0064 FC01      		movw r30,r24
 269 0066 2083      		st Z,r18
  48:source/os_rios/UART.c ****   buffercount = buffercount - 1;
 270               		.stabn	68,0,48,.LM20-.LFBB3
 271               	.LM20:
 272 0068 8091 0000 		lds r24,buffercount
 273 006c 9091 0000 		lds r25,buffercount+1
 274 0070 0197      		sbiw r24,1
 275 0072 9093 0000 		sts buffercount+1,r25
 276 0076 8093 0000 		sts buffercount,r24
  49:source/os_rios/UART.c **** 
  50:source/os_rios/UART.c ****   /* Here is another hack to reset the value of index when we hit BUFFERSIZE
  51:source/os_rios/UART.c ****   * Using modulus operator gives us the remainder of a divison. Our BUFFERSIZE
  52:source/os_rios/UART.c ****   * is the maximum value of the size, so for every value that is less than
  53:source/os_rios/UART.c ****   * BUFFERSIZE the value fo the index from the below expression is itself.
  54:source/os_rios/UART.c ****   * When we reach BUFFERSIZE, the value will be zero.
  55:source/os_rios/UART.c ****   */
  56:source/os_rios/UART.c ****   rxBuffer.readindex = ((rxBuffer.readindex)+1) % BUFFERSIZE;
 277               		.stabn	68,0,56,.LM21-.LFBB3
 278               	.LM21:
 279 007a 8091 0000 		lds r24,rxBuffer+1024
 280 007e 90E0      		ldi r25,0
 281 0080 0196      		adiw r24,1
 282 0082 8093 0000 		sts rxBuffer+1024,r24
  57:source/os_rios/UART.c ****   return BUFFER_OK;
 283               		.stabn	68,0,57,.LM22-.LFBB3
 284               	.LM22:
 285 0086 80E0      		ldi r24,0
 286 0088 90E0      		ldi r25,0
  58:source/os_rios/UART.c **** }
 287               		.stabn	68,0,58,.LM23-.LFBB3
 288               	.LM23:
 289 008a 0895      		ret
 290               		.size	rxBufferRead, .-rxBufferRead
 291               	.Lscope3:
 292               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 293               		.stabd	78,0,0
 294               		.stabs	"rxBufferWrite:F(1,1)",36,0,61,rxBufferWrite
 295               	.global	rxBufferWrite
 296               		.type	rxBufferWrite, @function
 297               	rxBufferWrite:
 298               		.stabd	46,0,0
  59:source/os_rios/UART.c **** 
  60:source/os_rios/UART.c **** 
  61:source/os_rios/UART.c **** enum bufferStatus rxBufferWrite(){
 299               		.stabn	68,0,61,.LM24-.LFBB4
 300               	.LM24:
 301               	.LFBB4:
 302               	/* prologue: function */
 303               	/* frame size = 0 */
 304               	/* stack size = 0 */
 305               	.L__stack_usage = 0
  62:source/os_rios/UART.c ****   // That modulus thing again, although  we will write it out for readablity
  63:source/os_rios/UART.c ****   unsigned char insertindex = ((rxBuffer.writeindex)+1) % BUFFERSIZE;
 306               		.stabn	68,0,63,.LM25-.LFBB4
 307               	.LM25:
 308 008c 8091 0000 		lds r24,rxBuffer+1025
 309 0090 90E0      		ldi r25,0
 310 0092 0196      		adiw r24,1
  64:source/os_rios/UART.c **** 
  65:source/os_rios/UART.c ****   // Check if the next element if someting that needs to be read out. If it is
  66:source/os_rios/UART.c ****   // the buffer is definitely full.
  67:source/os_rios/UART.c ****   if (insertindex == (rxBuffer.readindex)) {
 311               		.stabn	68,0,67,.LM26-.LFBB4
 312               	.LM26:
 313 0094 2091 0000 		lds r18,rxBuffer+1024
 314 0098 2813      		cpse r18,r24
 315 009a 00C0      		rjmp .L13
  68:source/os_rios/UART.c ****     /* This would mean the buffer is full. But what shoudl we do if the buffer
  69:source/os_rios/UART.c ****      * is full. Why just return. UDR0 itself is hardware buffered. So are very
  70:source/os_rios/UART.c ****      * less likely to lose any data. But in case we reach that point we just
  71:source/os_rios/UART.c ****      * wait until something is read.
  72:source/os_rios/UART.c ****      */
  73:source/os_rios/UART.c ****     softwareserialTransmit(0xFF);
 316               		.stabn	68,0,73,.LM27-.LFBB4
 317               	.LM27:
 318 009c 8FEF      		ldi r24,lo8(-1)
 319 009e 0E94 0000 		call softwareserialTransmit
  74:source/os_rios/UART.c ****     return BUFFER_FULL;
 320               		.stabn	68,0,74,.LM28-.LFBB4
 321               	.LM28:
 322 00a2 82E0      		ldi r24,lo8(2)
 323 00a4 90E0      		ldi r25,0
 324 00a6 0895      		ret
 325               	.L13:
  75:source/os_rios/UART.c ****   }
  76:source/os_rios/UART.c ****   // Read the variable from UDR0 into the buffer
  77:source/os_rios/UART.c ****   rxBuffer.data[rxBuffer.writeindex] = UDR0;
 326               		.stabn	68,0,77,.LM29-.LFBB4
 327               	.LM29:
 328 00a8 E091 0000 		lds r30,rxBuffer+1025
 329 00ac F0E0      		ldi r31,0
 330 00ae 9091 C600 		lds r25,198
 331 00b2 E050      		subi r30,lo8(-(rxBuffer))
 332 00b4 F040      		sbci r31,hi8(-(rxBuffer))
 333 00b6 9083      		st Z,r25
  78:source/os_rios/UART.c ****   buffercount = (buffercount+1) % BUFFERSIZE;
 334               		.stabn	68,0,78,.LM30-.LFBB4
 335               	.LM30:
 336 00b8 2091 0000 		lds r18,buffercount
 337 00bc 3091 0000 		lds r19,buffercount+1
 338 00c0 2F5F      		subi r18,-1
 339 00c2 3F4F      		sbci r19,-1
 340 00c4 3370      		andi r19,3
 341 00c6 3093 0000 		sts buffercount+1,r19
 342 00ca 2093 0000 		sts buffercount,r18
  79:source/os_rios/UART.c **** 
  80:source/os_rios/UART.c ****   // Increment the index
  81:source/os_rios/UART.c ****   rxBuffer.writeindex = insertindex;
 343               		.stabn	68,0,81,.LM31-.LFBB4
 344               	.LM31:
 345 00ce 8093 0000 		sts rxBuffer+1025,r24
  82:source/os_rios/UART.c ****   return BUFFER_OK;
 346               		.stabn	68,0,82,.LM32-.LFBB4
 347               	.LM32:
 348 00d2 80E0      		ldi r24,0
 349 00d4 90E0      		ldi r25,0
  83:source/os_rios/UART.c **** }
 350               		.stabn	68,0,83,.LM33-.LFBB4
 351               	.LM33:
 352 00d6 0895      		ret
 353               		.size	rxBufferWrite, .-rxBufferWrite
 354               	.Lscope4:
 355               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 356               		.stabd	78,0,0
 357               		.stabs	"__vector_18:F(0,49)",36,0,90,__vector_18
 358               	.global	__vector_18
 359               		.type	__vector_18, @function
 360               	__vector_18:
 361               		.stabd	46,0,0
  84:source/os_rios/UART.c **** 
  85:source/os_rios/UART.c **** /******************************************************************************/
  86:source/os_rios/UART.c **** /*                          INTERRUPT SERVICE ROUTINES                        */
  87:source/os_rios/UART.c **** /******************************************************************************/
  88:source/os_rios/UART.c **** 
  89:source/os_rios/UART.c **** /* USART RECEIVE INTERRUPT SERVICE ROUTINE */
  90:source/os_rios/UART.c **** ISR(USART_RX_vect){
 362               		.stabn	68,0,90,.LM34-.LFBB5
 363               	.LM34:
 364               	.LFBB5:
 365 00d8 1F92      		push r1
 366 00da 0F92      		push r0
 367 00dc 0FB6      		in r0,__SREG__
 368 00de 0F92      		push r0
 369 00e0 1124      		clr __zero_reg__
 370 00e2 2F93      		push r18
 371 00e4 3F93      		push r19
 372 00e6 4F93      		push r20
 373 00e8 5F93      		push r21
 374 00ea 6F93      		push r22
 375 00ec 7F93      		push r23
 376 00ee 8F93      		push r24
 377 00f0 9F93      		push r25
 378 00f2 AF93      		push r26
 379 00f4 BF93      		push r27
 380 00f6 EF93      		push r30
 381 00f8 FF93      		push r31
 382               	/* prologue: Signal */
 383               	/* frame size = 0 */
 384               	/* stack size = 15 */
 385               	.L__stack_usage = 15
  91:source/os_rios/UART.c ****   // Set flag to one
  92:source/os_rios/UART.c ****   USART_is_receiving = 1;
 386               		.stabn	68,0,92,.LM35-.LFBB5
 387               	.LM35:
 388 00fa 81E0      		ldi r24,lo8(1)
 389 00fc 8093 0000 		sts USART_is_receiving,r24
  93:source/os_rios/UART.c ****   /* We want our interrupt service routine to be quick as possible. Which is why
  94:source/os_rios/UART.c ****    * all this routine will do is write to the ring buffer and get out. However,
  95:source/os_rios/UART.c ****    * we need our cpu to be quicker so that elements from that buffer are emptied
  96:source/os_rios/UART.c ****    * faster than this ISR can populate the buffer. This was one of the prime
  97:source/os_rios/UART.c ****    * reasons why the chosen clock was 4 Mhz.*/
  98:source/os_rios/UART.c ****   if((rxBufferWrite() != BUFFER_OK)){
 390               		.stabn	68,0,98,.LM36-.LFBB5
 391               	.LM36:
 392 0100 0E94 0000 		call rxBufferWrite
 393 0104 892B      		or r24,r25
 394 0106 01F0      		breq .L16
  99:source/os_rios/UART.c ****     readLIDAR();
 395               		.stabn	68,0,99,.LM37-.LFBB5
 396               	.LM37:
 397 0108 0E94 0000 		call readLIDAR
 100:source/os_rios/UART.c ****     rxBufferWrite();
 398               		.stabn	68,0,100,.LM38-.LFBB5
 399               	.LM38:
 400 010c 0E94 0000 		call rxBufferWrite
 401               	.L16:
 101:source/os_rios/UART.c ****   }
 102:source/os_rios/UART.c **** 
 103:source/os_rios/UART.c ****   // Set it off when done
 104:source/os_rios/UART.c ****   USART_is_receiving = 0;
 402               		.stabn	68,0,104,.LM39-.LFBB5
 403               	.LM39:
 404 0110 1092 0000 		sts USART_is_receiving,__zero_reg__
 405               	/* epilogue start */
 105:source/os_rios/UART.c **** }
 406               		.stabn	68,0,105,.LM40-.LFBB5
 407               	.LM40:
 408 0114 FF91      		pop r31
 409 0116 EF91      		pop r30
 410 0118 BF91      		pop r27
 411 011a AF91      		pop r26
 412 011c 9F91      		pop r25
 413 011e 8F91      		pop r24
 414 0120 7F91      		pop r23
 415 0122 6F91      		pop r22
 416 0124 5F91      		pop r21
 417 0126 4F91      		pop r20
 418 0128 3F91      		pop r19
 419 012a 2F91      		pop r18
 420 012c 0F90      		pop r0
 421 012e 0FBE      		out __SREG__,r0
 422 0130 0F90      		pop r0
 423 0132 1F90      		pop r1
 424 0134 1895      		reti
 425               		.size	__vector_18, .-__vector_18
 426               	.Lscope5:
 427               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 428               		.stabd	78,0,0
 429               		.comm	buffercount,2,1
 430               		.comm	USART_is_receiving,1,1
 431               		.comm	rxBuffer,1026,1
 432               		.comm	obstacle,3,1
 433               		.comm	tfmini,9,1
 434               		.stabs	"tfmini:G(0,51)=B(7,2)",32,0,58,0
 435               		.stabs	"obstacle:G(0,52)=B(7,4)",32,0,66,0
 436               		.stabs	"rxBuffer:G(0,53)=B(1,5)",32,0,37,0
 437               		.stabs	"USART_is_receiving:G(0,54)=B(0,13)",32,0,38,0
 438               		.stabs	"buffercount:G(0,55)=B(0,4)",32,0,39,0
 439               		.stabs	"",100,0,0,.Letext0
 440               	.Letext0:
 441               		.ident	"GCC: (GNU) 5.4.0"
 442               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 UART.c
     /tmp/ccJvMAip.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccJvMAip.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccJvMAip.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccJvMAip.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccJvMAip.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccJvMAip.s:116    .text:0000000000000000 usartinit
     /tmp/ccJvMAip.s:139    .text:0000000000000008 softwareserialTransmit
     /tmp/ccJvMAip.s:234    .text:0000000000000040 rxBufferRead
                            *COM*:0000000000000402 rxBuffer
                            *COM*:0000000000000002 buffercount
     /tmp/ccJvMAip.s:297    .text:000000000000008c rxBufferWrite
     /tmp/ccJvMAip.s:360    .text:00000000000000d8 __vector_18
                            *COM*:0000000000000001 USART_is_receiving
                            *COM*:0000000000000003 obstacle
                            *COM*:0000000000000009 tfmini

UNDEFINED SYMBOLS
hardwareserialsetup
softwareserialsetup
readLIDAR
__do_clear_bss
